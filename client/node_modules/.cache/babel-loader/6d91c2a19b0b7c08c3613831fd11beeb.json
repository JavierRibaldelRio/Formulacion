{"ast":null,"code":"//Importaciones\nimport identificarSustanciasSimples from './SustanciasSimples';\nimport descartarCartasUsadas from './eliminarCompuestos';\nimport crearMapaCompuesto from './crearMapaCompuesto'; //Funcion que comprueva si es posible crear este compuesto\n\nfunction comprobarCompuesto(elementos, compuesto) {\n  //Error que sacara por pantalla\n  const errorCompuesto = \"Este compuesto no se puede crear\"; //Cromprovar si compuesto no es un texto\n\n  if (typeof compuesto != \"string\") {\n    //Error\n    console.log(typeof compuesto);\n  } //si es un string\n  else {\n      compuesto = compuesto.trim(); //Quita si hay los primes y ultimos espacios\n\n      compuesto = compuesto.toLocaleLowerCase(); //Pasa a minusculas\n\n      const mapElementos = crearMap(); //Crear el mapa de les elementos\n\n      const compuestoPartido = compuesto.split(\" \"); //Comprueba las sustancias simples\n\n      if (compuestoPartido.length === 1) {\n        var salidaSS = identificarSustanciasSimples(compuestoPartido[0], elementos, mapElementos);\n\n        if (salidaSS !== false) {\n          //Crea el mapa del compuesto\n          var mapaCompuesto = new Map(); //Añade el elemento al mapa\n\n          mapaCompuesto.set(salidaSS, 2); //eliminar las cartas que han sido usadas\n\n          descartarCartasUsadas(crearMapaCompuesto([salidaSS.nombre.toLocaleLowerCase()], [2]), elementos); //Devulve la puntuación \n\n          return calcularPuntuacion(mapaCompuesto);\n        } else {\n          return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n        }\n      } //Comprueba si es un hidruro\n      else if (compuesto.includes(hidruro) && buscarElementoEnMapa(mapElementos, \"H\")) {\n          return comprobarCompuestoBinario(hidruro, compuesto, mapElementos, elementos);\n        } //comprobar si abace en uro\n        else if (compuestoPartido[0].endsWith(sufijo16Y17) && compuestoPartido[2].endsWith(\"hidrógeno\") && comprobarSiHayHidrogeno(mapElementos)) {\n            console.log(\"AnfigenoHAlogeno\"); //Preparar datos para la función de averiguar\n            //Coger la ultima palabra de el array, \n\n            const prefijoTexto = compuestoPartido[2].split(\"hidrógeno\"); //Almacena el prefijo del hidrogeno\n\n            var prefijo; //Si no hay prefijo o es mono\n\n            if (prefijoTexto[0] === \"\" || prefijoTexto === prefijos[1]) {\n              prefijo = 1;\n            } //es di\n            else if (prefijoTexto[0] === prefijos[2]) {\n                prefijo = 2;\n              } else {\n                return false;\n              }\n\n            const salida = averiguarHalogenosYAnfigenos(compuesto, mapElementos, prefijo, elementos);\n            return salida;\n          } else if (compuesto.includes(oxido) && buscarElementoEnMapa(mapElementos, \"O\")) {\n            return comprobarCompuestoBinario(oxido, compuesto, mapElementos, elementos);\n          } //Parte de sales binarias\n          else {\n              //MIra si es correcto y lo almacena\n              let correcto = comprobarSalesBinariasVolatiles(compuesto, mapElementos, elementos);\n\n              if (typeof correcto === \"boolean\") {\n                return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n              } else {\n                return correcto;\n              }\n\n              return false;\n            }\n    } //Funciones\n  //Devuelve un mapa <objeto|Nº de repeticiones de ese objeto>\n\n\n  function crearMap() {\n    var mapaElementos = new Map(); //Map donde se almacenan el numero de repeticiones de cada elmento\n    //Se ejecuta una vez por el número de elementos que hay que coger\n\n    for (var i = 0; i < elementos.length; i++) {\n      var elementoOriginal = elementos[i]; //Almacena el elemento origianl\n\n      var contador = 1; //Cuenta cuantas veces se repite un elemento\n      //si es igual al número \n\n      if (i < elementos.length - 1) {\n        //repetira esto hasta que el elemento cambie\n        while (i < elementos.length - 1 && elementoOriginal.sq == elementos[1 + i].sq) {\n          i++;\n          contador++;\n        }\n      }\n\n      mapaElementos.set(elementoOriginal, contador); //Añade al mapa\n    }\n\n    return mapaElementos; //Retorna el mapa\n  } //Funcion para comprobar que prefijo es\n\n} //Devuelve que prefijo a sido a utilizado, por lo tanto el número\n\n\nfunction encontrarPrefijo(particula) {\n  //Se repirte una vez por el número de prefijos que haya\n  for (var i = 1; i < numeroDePrefijos; i++) {\n    //Si la particula es la misma que el prefijo\n    if (particula.startsWith(prefijos[i])) {\n      return i; //Devuelve el número de la particula\n    }\n  }\n\n  return -1;\n} //Funcion para saber si el usuario tiene los elementos necesarios para poder crear el compuesto\n\n/*Hidrogeno*/\n\n/*1*/\n\n/*Litio*/\n\n/*1*/\n\n\nfunction comprobarSiPuedeGenerarCompuestos(primeraPalabra, prefijoPrimeraPalabra, segundaPalabra, prefijoSegundaPalabra, mapa) {\n  //Mirar si tiene los formatos correctos (2 textos y 2 números)\n  if (posibleTexto(primeraPalabra) && posibleTexto(segundaPalabra) && posibleNumero(prefijoPrimeraPalabra) && posibleNumero(prefijoSegundaPalabra)) {\n    //Se asegura de que la suma de los dos prefijos es menor que al número total de prefijos\n    if (prefijoPrimeraPalabra + prefijoSegundaPalabra <= numeroDePrefijos) {\n      //Eliminar los Nitrogenoides el carbonoide\n      //Asegurarse de que el compuesto esta simplificado al máximo\n      if (prefijoPrimeraPalabra > 1 && prefijoSegundaPalabra > 1) {\n        //Almacena el valor maximo del número de oxidación\n        var max, min; //Almacena el resultado de la división de max/min\n\n        let division; //Si el mayor es primero\n\n        if (prefijoPrimeraPalabra > prefijoSegundaPalabra) {\n          max = prefijoPrimeraPalabra;\n          min = prefijoSegundaPalabra;\n        } //sino\n        else {\n            max = prefijoSegundaPalabra;\n            min = prefijoPrimeraPalabra;\n          } //Divide el máximo entre el mínimo\n\n\n        division = max / min;\n        console.log(\"funciona correctamente\");\n        console.info(division); //Si el valor de la division es igual a la prate entera de la división\n        //Es decir comprueba si es entero o decimal\n\n        if (division === Math.floor(division)\n        /*Math.floor() saca la parte entera de la coma*/\n        ) {\n            return false;\n          }\n      } //Se asegura de que los compuestos estan\n\n\n      if (comprobarSiEstanLosCompuestos(primeraPalabra, prefijoPrimeraPalabra, mapa) && comprobarSiEstanLosCompuestos(segundaPalabra, prefijoSegundaPalabra, mapa)) {\n        //Almaceno lo que se va ha devolver\n        var devol; //Array de objetos que almacena los objetos utilizados para este compuesto\n\n        var arrayCompuesto = crearArrayCompuesto(); //Crea un array corresponde al compuesto\n\n        if (arrayCompuesto[0].nombre.toLocaleLowerCase() === hidrogeno) {\n          console.log(\"CArbonoides,Nitrogenoides\");\n\n          if (arrayCompuesto[1].grupo === 15) {\n            if (prefijoPrimeraPalabra != 3) {\n              return false;\n            }\n          } else if (arrayCompuesto[1].nombre.toLocaleLowerCase() === carbono) {\n            if (prefijoPrimeraPalabra != 4) {\n              return false;\n            }\n          }\n        } //Devolver el valor de neutro\n\n\n        const devolver = neutro();\n\n        if (devolver === true) {\n          //Calcula puntaución, la cual requiere un mapa de el compuesto, para eso utilizo la función de crearMapaCompuesto la cual pide un array de elemen\n          devol = calcularPuntuacion(crearMapaCompuestoPuntuacion(arrayCompuesto, [prefijoPrimeraPalabra, prefijoSegundaPalabra]));\n        } else {\n          devol = false;\n        }\n\n        return devol; //funcion que dice si da neutro (0) o estable\n\n        function neutro() {\n          var valencias1, valencias2; //Crea el array de valencias sumadas de cada elemento\n\n          valencias1 = operar(arrayCompuesto[0].v, prefijoPrimeraPalabra);\n          valencias2 = operar(arrayCompuesto[1].v, prefijoSegundaPalabra); //Comprueva si la suma de los arrays de valencias es neutro\n\n          if (sumar(valencias1, valencias2)) {\n            return true;\n          } else {\n            return -1;\n          } //Suma todas las casillas de todos los arrays\n\n\n          function sumar(array1, array2) {\n            //Coge la casilla indicada del array\n            for (var i = 0; i < array1.length; i++) {\n              //Coge la casilla indicada del 2º array\n              for (var j = 0; j < array2.length; j++) {\n                //Si la suma de los arrays es o deveulve true por que es neutro\n                if (array1[i] + array2[j] === 0) {\n                  return true;\n                }\n              }\n            } //Si no devuelve true devulve false\n\n\n            return false;\n          } //Multiplica las valencias por el numero de repeticiones del elmetneo\n\n\n          function operar(valencias, repeticiones) {\n            var arrayVuelta = []; //El array que devolveras\n            // Se ejecuta una ve por cada casilla del array\n\n            for (var i = 0; i < valencias.length; i++) {\n              //Multiplica la casilla de la valencia por las repeticiones y la añade al array\n              arrayVuelta.push(valencias[i] * repeticiones);\n            }\n\n            return arrayVuelta; //Multiplica el array\n          }\n        } //Función que estrae los datos necesarios\n\n\n        function crearArrayCompuesto() {\n          var arrayCompuesto = []; //Crea el a el array\n          //Se ejecuta una vez por cada elemento del array\n\n          mapa.forEach(function (valor, key) {\n            anadir(primeraPalabra, key);\n          }); //Se ejecuta una vez por cada elemento del array\n\n          mapa.forEach(function (valor, key) {\n            anadir(segundaPalabra, key);\n          }); //Añade el elemento al array\n\n          function anadir(palabra, key) {\n            //Si es igual lo añade\n            if (key.nombre.toLocaleLowerCase() === palabra) {\n              arrayCompuesto.push(key); //Añade al array la palabra\n            }\n          }\n\n          return arrayCompuesto; // Devuelve el array\n        }\n      }\n    } //Error\n    else {\n        return -1;\n      } //Error    \n\n  } else {\n    return -1;\n  } //Comueva si es un texto\n\n\n  function posibleTexto(text) {\n    return typeof text === \"string\";\n  } //Compreuva si es un numero\n\n\n  function posibleNumero(numero) {\n    return typeof numero === \"number\";\n  } //funcion para comprobar si esta el elemento\n\n\n  function comprobarSiEstanLosCompuestos(nombre, numero, map) {\n    var devolucion = false; //Variable que será devuelta\n\n    map.forEach(function (value, key) {\n      //Comprueva si el elemento esta dentro del map  y tiene tantas repeticiones como es indicado por el prfijo\n      if (key.nombre.toLocaleLowerCase() === nombre && value >= numero) {\n        devolucion = true;\n      }\n    });\n    return devolucion;\n  }\n} //funcion àra coomprovar si hay hidrogeno\n\n\nfunction comprobarSiHayHidrogeno(mapaElementos) {\n  var devolver = false; //Lo que se devolvera\n  //Mirar si el hidrogeno se encuentra en el mapa de los elementos\n\n  mapaElementos.forEach(function (value, key) {\n    const sqElemento = key.sq; //Coge de la clave\n    //Si el sq es igual a la del hidrógeno\n\n    if (sqElemento === \"H\") {\n      devolver = true; //Cambia la devolución a true\n    }\n  });\n  return devolver; //Devuelve\n}\n\nexport default comprobarCompuesto;\nexport { comprobarSiHayHidrogeno };","map":{"version":3,"sources":["/home/javi/Programacion/Web/Formulacion/src/funcionCompuesto.js"],"names":["identificarSustanciasSimples","descartarCartasUsadas","crearMapaCompuesto","comprobarCompuesto","elementos","compuesto","errorCompuesto","console","log","trim","toLocaleLowerCase","mapElementos","crearMap","compuestoPartido","split","length","salidaSS","mapaCompuesto","Map","set","nombre","calcularPuntuacion","identificarCompuestosExcepcionales","includes","hidruro","buscarElementoEnMapa","comprobarCompuestoBinario","endsWith","sufijo16Y17","comprobarSiHayHidrogeno","prefijoTexto","prefijo","prefijos","salida","averiguarHalogenosYAnfigenos","oxido","correcto","comprobarSalesBinariasVolatiles","mapaElementos","i","elementoOriginal","contador","sq","encontrarPrefijo","particula","numeroDePrefijos","startsWith","comprobarSiPuedeGenerarCompuestos","primeraPalabra","prefijoPrimeraPalabra","segundaPalabra","prefijoSegundaPalabra","mapa","posibleTexto","posibleNumero","max","min","division","info","Math","floor","comprobarSiEstanLosCompuestos","devol","arrayCompuesto","crearArrayCompuesto","hidrogeno","grupo","carbono","devolver","neutro","crearMapaCompuestoPuntuacion","valencias1","valencias2","operar","v","sumar","array1","array2","j","valencias","repeticiones","arrayVuelta","push","forEach","valor","key","anadir","palabra","text","numero","map","devolucion","value","sqElemento"],"mappings":"AAAA;AAEA,OAAOA,4BAAP,MAAyC,qBAAzC;AACA,OAAOC,qBAAP,MAAkC,sBAAlC;AACA,OAAOC,kBAAP,MAA+B,sBAA/B,C,CAIA;;AACA,SAASC,kBAAT,CAA4BC,SAA5B,EAAuCC,SAAvC,EAAkD;AAE9C;AACA,QAAMC,cAAc,GAAG,kCAAvB,CAH8C,CAK9C;;AACA,MAAI,OAAOD,SAAP,IAAoB,QAAxB,EAAkC;AAE9B;AAEAE,IAAAA,OAAO,CAACC,GAAR,CAAY,OAAOH,SAAnB;AAEH,GAND,CAOA;AAPA,OAQK;AAEDA,MAAAA,SAAS,GAAGA,SAAS,CAACI,IAAV,EAAZ,CAFC,CAE6B;;AAE9BJ,MAAAA,SAAS,GAAGA,SAAS,CAACK,iBAAV,EAAZ,CAJC,CAI2C;;AAE5C,YAAMC,YAAY,GAAGC,QAAQ,EAA7B,CANC,CAMmC;;AAEpC,YAAMC,gBAAgB,GAAGR,SAAS,CAACS,KAAV,CAAgB,GAAhB,CAAzB,CARC,CASD;;AAEA,UAAID,gBAAgB,CAACE,MAAjB,KAA4B,CAAhC,EAAmC;AAE/B,YAAIC,QAAQ,GAAGhB,4BAA4B,CAACa,gBAAgB,CAAC,CAAD,CAAjB,EAAsBT,SAAtB,EAAiCO,YAAjC,CAA3C;;AAEA,YAAIK,QAAQ,KAAK,KAAjB,EAAwB;AAEpB;AACA,cAAIC,aAAa,GAAG,IAAIC,GAAJ,EAApB,CAHoB,CAKpB;;AACAD,UAAAA,aAAa,CAACE,GAAd,CAAkBH,QAAlB,EAA4B,CAA5B,EANoB,CAQpB;;AACAf,UAAAA,qBAAqB,CAACC,kBAAkB,CAAC,CAACc,QAAQ,CAACI,MAAT,CAAgBV,iBAAhB,EAAD,CAAD,EAAwC,CAAC,CAAD,CAAxC,CAAnB,EAAiEN,SAAjE,CAArB,CAToB,CAWpB;;AACA,iBAAOiB,kBAAkB,CAACJ,aAAD,CAAzB;AAGH,SAfD,MAeO;AAEH,iBAAOK,kCAAkC,CAACjB,SAAD,EAAYM,YAAZ,EAA0BP,SAA1B,CAAzC;AAEH;AAKJ,OA5BD,CA6BA;AA7BA,WA8BK,IAAIC,SAAS,CAACkB,QAAV,CAAmBC,OAAnB,KAA+BC,oBAAoB,CAACd,YAAD,EAAe,GAAf,CAAvD,EAA4E;AAE7E,iBAAOe,yBAAyB,CAACF,OAAD,EAAUnB,SAAV,EAAqBM,YAArB,EAAmCP,SAAnC,CAAhC;AAEH,SAJI,CAML;AANK,aAOA,IAAIS,gBAAgB,CAAC,CAAD,CAAhB,CAAoBc,QAApB,CAA6BC,WAA7B,KAA6Cf,gBAAgB,CAAC,CAAD,CAAhB,CAAoBc,QAApB,CAA6B,WAA7B,CAA7C,IAA0FE,uBAAuB,CAAClB,YAAD,CAArH,EAAqI;AAEtIJ,YAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAFsI,CAItI;AAEA;;AACA,kBAAMsB,YAAY,GAAGjB,gBAAgB,CAAC,CAAD,CAAhB,CAAoBC,KAApB,CAA0B,WAA1B,CAArB,CAPsI,CAStI;;AACA,gBAAIiB,OAAJ,CAVsI,CAatI;;AACA,gBAAID,YAAY,CAAC,CAAD,CAAZ,KAAoB,EAApB,IAA0BA,YAAY,KAAKE,QAAQ,CAAC,CAAD,CAAvD,EAA4D;AAExDD,cAAAA,OAAO,GAAG,CAAV;AAEH,aAJD,CAKA;AALA,iBAMK,IAAID,YAAY,CAAC,CAAD,CAAZ,KAAoBE,QAAQ,CAAC,CAAD,CAAhC,EAAqC;AAEtCD,gBAAAA,OAAO,GAAG,CAAV;AAEH,eAJI,MAIE;AACH,uBAAO,KAAP;AACH;;AAED,kBAAME,MAAM,GAAGC,4BAA4B,CAAC7B,SAAD,EAAYM,YAAZ,EAA0BoB,OAA1B,EAAmC3B,SAAnC,CAA3C;AAEA,mBAAO6B,MAAP;AACH,WA/BI,MAiCA,IAAI5B,SAAS,CAACkB,QAAV,CAAmBY,KAAnB,KAA6BV,oBAAoB,CAACd,YAAD,EAAe,GAAf,CAArD,EAA0E;AAE3E,mBAAOe,yBAAyB,CAACS,KAAD,EAAQ9B,SAAR,EAAmBM,YAAnB,EAAiCP,SAAjC,CAAhC;AAEH,WAJI,CAML;AANK,eAOA;AAED;AACA,kBAAIgC,QAAQ,GAAGC,+BAA+B,CAAChC,SAAD,EAAYM,YAAZ,EAA0BP,SAA1B,CAA9C;;AAEA,kBAAI,OAAOgC,QAAP,KAAoB,SAAxB,EAAmC;AAE/B,uBAAOd,kCAAkC,CAACjB,SAAD,EAAYM,YAAZ,EAA0BP,SAA1B,CAAzC;AAEH,eAJD,MAIO;AAEH,uBAAOgC,QAAP;AAEH;;AAED,qBAAO,KAAP;AACH;AACJ,KAvH6C,CAyH9C;AAEA;;;AACA,WAASxB,QAAT,GAAoB;AAEhB,QAAI0B,aAAa,GAAG,IAAIpB,GAAJ,EAApB,CAFgB,CAEgB;AAEhC;;AACA,SAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnC,SAAS,CAACW,MAA9B,EAAsCwB,CAAC,EAAvC,EAA2C;AAEvC,UAAIC,gBAAgB,GAAGpC,SAAS,CAACmC,CAAD,CAAhC,CAFuC,CAEF;;AAErC,UAAIE,QAAQ,GAAG,CAAf,CAJuC,CAInB;AAEpB;;AACA,UAAIF,CAAC,GAAGnC,SAAS,CAACW,MAAV,GAAmB,CAA3B,EAA8B;AAE1B;AACA,eAAOwB,CAAC,GAAGnC,SAAS,CAACW,MAAV,GAAmB,CAAvB,IAA4ByB,gBAAgB,CAACE,EAAjB,IAAuBtC,SAAS,CAAC,IAAImC,CAAL,CAAT,CAAiBG,EAA3E,EAA+E;AAE3EH,UAAAA,CAAC;AAEDE,UAAAA,QAAQ;AAEX;AAEJ;;AACDH,MAAAA,aAAa,CAACnB,GAAd,CAAkBqB,gBAAlB,EAAoCC,QAApC,EAnBuC,CAmBS;AAEnD;;AAED,WAAOH,aAAP,CA5BgB,CA4BQ;AAC3B,GAzJ6C,CA4J9C;;AAEH,C,CAED;;;AACA,SAASK,gBAAT,CAA0BC,SAA1B,EAAqC;AAEjC;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,gBAApB,EAAsCN,CAAC,EAAvC,EAA2C;AAEvC;AACA,QAAIK,SAAS,CAACE,UAAV,CAAqBd,QAAQ,CAACO,CAAD,CAA7B,CAAJ,EAAuC;AAEnC,aAAOA,CAAP,CAFmC,CAEvB;AAEf;AAEJ;;AAED,SAAO,CAAC,CAAR;AAEH,C,CAED;;AACA;;AAAgB;;AAAwB;;AAAgB;;;AACxD,SAASQ,iCAAT,CAA2CC,cAA3C,EAA2DC,qBAA3D,EAAkFC,cAAlF,EAAkGC,qBAAlG,EAAyHC,IAAzH,EAA+H;AAE3H;AACA,MAAIC,YAAY,CAACL,cAAD,CAAZ,IAAgCK,YAAY,CAACH,cAAD,CAA5C,IAAgEI,aAAa,CAACL,qBAAD,CAA7E,IAAwGK,aAAa,CAACH,qBAAD,CAAzH,EAAkJ;AAE9I;AACA,QAAIF,qBAAqB,GAAGE,qBAAxB,IAAiDN,gBAArD,EAAuE;AAEnE;AAGA;AACA,UAAII,qBAAqB,GAAG,CAAxB,IAA6BE,qBAAqB,GAAG,CAAzD,EAA4D;AAExD;AAEA,YAAII,GAAJ,EAASC,GAAT,CAJwD,CAMxD;;AAEA,YAAIC,QAAJ,CARwD,CAUxD;;AACA,YAAIR,qBAAqB,GAAGE,qBAA5B,EAAmD;AAE/CI,UAAAA,GAAG,GAAGN,qBAAN;AAEAO,UAAAA,GAAG,GAAGL,qBAAN;AAEH,SAND,CAOA;AAPA,aAQK;AACDI,YAAAA,GAAG,GAAGJ,qBAAN;AAEAK,YAAAA,GAAG,GAAGP,qBAAN;AAEH,WAxBuD,CA0BxD;;;AACAQ,QAAAA,QAAQ,GAAGF,GAAG,GAAGC,GAAjB;AAEAjD,QAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ;AAEAD,QAAAA,OAAO,CAACmD,IAAR,CAAaD,QAAb,EA/BwD,CAiCxD;AACA;;AAEA,YAAIA,QAAQ,KAAKE,IAAI,CAACC,KAAL,CAAWH,QAAX;AAAoB;AAArC,UAAuF;AAEnF,mBAAO,KAAP;AAEH;AAGJ,OAjDkE,CAmDnE;;;AACA,UAAII,6BAA6B,CAACb,cAAD,EAAiBC,qBAAjB,EAAwCG,IAAxC,CAA7B,IAA8ES,6BAA6B,CAACX,cAAD,EAAiBC,qBAAjB,EAAwCC,IAAxC,CAA/G,EAA8J;AAE1J;AACA,YAAIU,KAAJ,CAH0J,CAK1J;;AACA,YAAIC,cAAc,GAAGC,mBAAmB,EAAxC,CAN0J,CAM9G;;AAE5C,YAAID,cAAc,CAAC,CAAD,CAAd,CAAkB3C,MAAlB,CAAyBV,iBAAzB,OAAiDuD,SAArD,EAAgE;AAE5D1D,UAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ;;AAEA,cAAIuD,cAAc,CAAC,CAAD,CAAd,CAAkBG,KAAlB,KAA4B,EAAhC,EAAoC;AAEhC,gBAAIjB,qBAAqB,IAAI,CAA7B,EAAgC;AAC5B,qBAAO,KAAP;AACH;AAEJ,WAND,MAMO,IAAIc,cAAc,CAAC,CAAD,CAAd,CAAkB3C,MAAlB,CAAyBV,iBAAzB,OAAiDyD,OAArD,EAA8D;AAEjE,gBAAIlB,qBAAqB,IAAI,CAA7B,EAAgC;AAC5B,qBAAO,KAAP;AACH;AAEJ;AAEJ,SA1ByJ,CA4B1J;;;AACA,cAAMmB,QAAQ,GAAGC,MAAM,EAAvB;;AAEA,YAAID,QAAQ,KAAK,IAAjB,EAAuB;AACnB;AACAN,UAAAA,KAAK,GAAGzC,kBAAkB,CAACiD,4BAA4B,CAACP,cAAD,EAAiB,CAACd,qBAAD,EAAwBE,qBAAxB,CAAjB,CAA7B,CAA1B;AAEH,SAJD,MAMK;AACDW,UAAAA,KAAK,GAAG,KAAR;AACH;;AAED,eAAOA,KAAP,CAzC0J,CA2C1J;;AAEA,iBAASO,MAAT,GAAkB;AAEd,cAAIE,UAAJ,EAAgBC,UAAhB,CAFc,CAId;;AACAD,UAAAA,UAAU,GAAGE,MAAM,CAACV,cAAc,CAAC,CAAD,CAAd,CAAkBW,CAAnB,EAAsBzB,qBAAtB,CAAnB;AAEAuB,UAAAA,UAAU,GAAGC,MAAM,CAACV,cAAc,CAAC,CAAD,CAAd,CAAkBW,CAAnB,EAAsBvB,qBAAtB,CAAnB,CAPc,CASd;;AACA,cAAIwB,KAAK,CAACJ,UAAD,EAAaC,UAAb,CAAT,EAAmC;AAE/B,mBAAO,IAAP;AAEH,WAJD,MAIO;AAEH,mBAAO,CAAC,CAAR;AACH,WAjBa,CAmBd;;;AAEA,mBAASG,KAAT,CAAeC,MAAf,EAAuBC,MAAvB,EAA+B;AAE3B;AACA,iBAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,MAAM,CAAC7D,MAA3B,EAAmCwB,CAAC,EAApC,EAAwC;AAEpC;AACA,mBAAK,IAAIuC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAAC9D,MAA3B,EAAmC+D,CAAC,EAApC,EAAwC;AAEpC;AACA,oBAAKF,MAAM,CAACrC,CAAD,CAAN,GAAYsC,MAAM,CAACC,CAAD,CAAnB,KAA4B,CAAhC,EAAmC;AAE/B,yBAAO,IAAP;AACH;AACJ;AACJ,aAd0B,CAgB3B;;;AACA,mBAAO,KAAP;AACH,WAvCa,CAyCd;;;AACA,mBAASL,MAAT,CAAgBM,SAAhB,EAA2BC,YAA3B,EAAyC;AAErC,gBAAIC,WAAW,GAAG,EAAlB,CAFqC,CAEb;AAExB;;AACA,iBAAK,IAAI1C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAAS,CAAChE,MAA9B,EAAsCwB,CAAC,EAAvC,EAA2C;AAEvC;AACA0C,cAAAA,WAAW,CAACC,IAAZ,CAAiBH,SAAS,CAACxC,CAAD,CAAT,GAAeyC,YAAhC;AAEH;;AAED,mBAAOC,WAAP,CAZqC,CAYb;AAE3B;AACJ,SAtGyJ,CAwG1J;;;AACA,iBAASjB,mBAAT,GAA+B;AAE3B,cAAID,cAAc,GAAG,EAArB,CAF2B,CAEC;AAE5B;;AACAX,UAAAA,IAAI,CAAC+B,OAAL,CAAa,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AAE/BC,YAAAA,MAAM,CAACtC,cAAD,EAAiBqC,GAAjB,CAAN;AAEH,WAJD,EAL2B,CAW3B;;AAEAjC,UAAAA,IAAI,CAAC+B,OAAL,CAAa,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AAE/BC,YAAAA,MAAM,CAACpC,cAAD,EAAiBmC,GAAjB,CAAN;AAEH,WAJD,EAb2B,CAmB3B;;AACA,mBAASC,MAAT,CAAgBC,OAAhB,EAAyBF,GAAzB,EAA8B;AAC1B;AACA,gBAAIA,GAAG,CAACjE,MAAJ,CAAWV,iBAAX,OAAmC6E,OAAvC,EAAgD;AAE5CxB,cAAAA,cAAc,CAACmB,IAAf,CAAoBG,GAApB,EAF4C,CAEhB;AAE/B;AACJ;;AAED,iBAAOtB,cAAP,CA7B2B,CA6BH;AAC3B;AAEJ;AAEJ,KA/LD,CAiMA;AAjMA,SAkMK;AACD,eAAO,CAAC,CAAR;AACH,OAvM6I,CAyM9I;;AACH,GA1MD,MA2MK;AAED,WAAO,CAAC,CAAR;AAEH,GAlN0H,CAqN3H;;;AACA,WAASV,YAAT,CAAsBmC,IAAtB,EAA4B;AAExB,WAAO,OAAOA,IAAP,KAAgB,QAAvB;AAEH,GA1N0H,CA4N3H;;;AAEA,WAASlC,aAAT,CAAuBmC,MAAvB,EAA+B;AAE3B,WAAO,OAAOA,MAAP,KAAkB,QAAzB;AAEH,GAlO0H,CAoO3H;;;AAEA,WAAS5B,6BAAT,CAAuCzC,MAAvC,EAA+CqE,MAA/C,EAAuDC,GAAvD,EAA4D;AAExD,QAAIC,UAAU,GAAG,KAAjB,CAFwD,CAEhC;;AAExBD,IAAAA,GAAG,CAACP,OAAJ,CAAY,UAAUS,KAAV,EAAiBP,GAAjB,EAAsB;AAG9B;AAEA,UAAIA,GAAG,CAACjE,MAAJ,CAAWV,iBAAX,OAAmCU,MAAnC,IAA6CwE,KAAK,IAAIH,MAA1D,EAAkE;AAE9DE,QAAAA,UAAU,GAAG,IAAb;AAEH;AACJ,KAVD;AAYA,WAAOA,UAAP;AAEH;AAEJ,C,CAED;;;AAEA,SAAS9D,uBAAT,CAAiCS,aAAjC,EAAgD;AAE5C,MAAI8B,QAAQ,GAAG,KAAf,CAF4C,CAEpB;AAExB;;AACA9B,EAAAA,aAAa,CAAC6C,OAAd,CAAsB,UAAUS,KAAV,EAAiBP,GAAjB,EAAsB;AAExC,UAAMQ,UAAU,GAAGR,GAAG,CAAC3C,EAAvB,CAFwC,CAEb;AAE3B;;AACA,QAAImD,UAAU,KAAK,GAAnB,EAAwB;AAEpBzB,MAAAA,QAAQ,GAAG,IAAX,CAFoB,CAEA;AAEvB;AACJ,GAVD;AAYA,SAAOA,QAAP,CAjB4C,CAiBxB;AAEvB;;AAED,eAAejE,kBAAf;AACA,SAAS0B,uBAAT","sourcesContent":["//Importaciones\n\nimport identificarSustanciasSimples from './SustanciasSimples';\nimport descartarCartasUsadas from './eliminarCompuestos';\nimport crearMapaCompuesto from './crearMapaCompuesto';\n\n\n\n//Funcion que comprueva si es posible crear este compuesto\nfunction comprobarCompuesto(elementos, compuesto) {\n\n    //Error que sacara por pantalla\n    const errorCompuesto = \"Este compuesto no se puede crear\";\n\n    //Cromprovar si compuesto no es un texto\n    if (typeof compuesto != \"string\") {\n\n        //Error\n\n        console.log(typeof compuesto);\n\n    }\n    //si es un string\n    else {\n\n        compuesto = compuesto.trim(); //Quita si hay los primes y ultimos espacios\n\n        compuesto = compuesto.toLocaleLowerCase();  //Pasa a minusculas\n\n        const mapElementos = crearMap();    //Crear el mapa de les elementos\n\n        const compuestoPartido = compuesto.split(\" \");\n        //Comprueba las sustancias simples\n\n        if (compuestoPartido.length === 1) {\n\n            var salidaSS = identificarSustanciasSimples(compuestoPartido[0], elementos, mapElementos);\n\n            if (salidaSS !== false) {\n\n                //Crea el mapa del compuesto\n                var mapaCompuesto = new Map();\n\n                //Añade el elemento al mapa\n                mapaCompuesto.set(salidaSS, 2);\n\n                //eliminar las cartas que han sido usadas\n                descartarCartasUsadas(crearMapaCompuesto([salidaSS.nombre.toLocaleLowerCase()], [2]), elementos);\n\n                //Devulve la puntuación \n                return calcularPuntuacion(mapaCompuesto);\n\n\n            } else {\n\n                return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n\n            }\n\n\n\n\n        }\n        //Comprueba si es un hidruro\n        else if (compuesto.includes(hidruro) && buscarElementoEnMapa(mapElementos, \"H\")) {\n\n            return comprobarCompuestoBinario(hidruro, compuesto, mapElementos, elementos);\n\n        }\n\n        //comprobar si abace en uro\n        else if (compuestoPartido[0].endsWith(sufijo16Y17) && compuestoPartido[2].endsWith(\"hidrógeno\") && comprobarSiHayHidrogeno(mapElementos)) {\n\n            console.log(\"AnfigenoHAlogeno\");\n\n            //Preparar datos para la función de averiguar\n\n            //Coger la ultima palabra de el array, \n            const prefijoTexto = compuestoPartido[2].split(\"hidrógeno\");\n\n            //Almacena el prefijo del hidrogeno\n            var prefijo;\n\n\n            //Si no hay prefijo o es mono\n            if (prefijoTexto[0] === \"\" || prefijoTexto === prefijos[1]) {\n\n                prefijo = 1;\n\n            }\n            //es di\n            else if (prefijoTexto[0] === prefijos[2]) {\n\n                prefijo = 2;\n\n            } else {\n                return false;\n            }\n\n            const salida = averiguarHalogenosYAnfigenos(compuesto, mapElementos, prefijo, elementos);\n\n            return salida;\n        }\n\n        else if (compuesto.includes(oxido) && buscarElementoEnMapa(mapElementos, \"O\")) {\n\n            return comprobarCompuestoBinario(oxido, compuesto, mapElementos, elementos);\n\n        }\n\n        //Parte de sales binarias\n        else {\n\n            //MIra si es correcto y lo almacena\n            let correcto = comprobarSalesBinariasVolatiles(compuesto, mapElementos, elementos);\n\n            if (typeof correcto === \"boolean\") {\n\n                return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n\n            } else {\n\n                return correcto;\n\n            }\n\n            return false;\n        }\n    }\n\n    //Funciones\n\n    //Devuelve un mapa <objeto|Nº de repeticiones de ese objeto>\n    function crearMap() {\n\n        var mapaElementos = new Map();  //Map donde se almacenan el numero de repeticiones de cada elmento\n\n        //Se ejecuta una vez por el número de elementos que hay que coger\n        for (var i = 0; i < elementos.length; i++) {\n\n            var elementoOriginal = elementos[i]; //Almacena el elemento origianl\n\n            var contador = 1;   //Cuenta cuantas veces se repite un elemento\n\n            //si es igual al número \n            if (i < elementos.length - 1) {\n\n                //repetira esto hasta que el elemento cambie\n                while (i < elementos.length - 1 && elementoOriginal.sq == elementos[1 + i].sq) {\n\n                    i++;\n\n                    contador++;\n\n                }\n\n            }\n            mapaElementos.set(elementoOriginal, contador);  //Añade al mapa\n\n        }\n\n        return mapaElementos;   //Retorna el mapa\n    }\n\n\n    //Funcion para comprobar que prefijo es\n\n}\n\n//Devuelve que prefijo a sido a utilizado, por lo tanto el número\nfunction encontrarPrefijo(particula) {\n\n    //Se repirte una vez por el número de prefijos que haya\n    for (var i = 1; i < numeroDePrefijos; i++) {\n\n        //Si la particula es la misma que el prefijo\n        if (particula.startsWith(prefijos[i])) {\n\n            return i;   //Devuelve el número de la particula\n\n        }\n\n    }\n\n    return -1;\n\n}\n\n//Funcion para saber si el usuario tiene los elementos necesarios para poder crear el compuesto\n/*Hidrogeno*/   /*1*/                   /*Litio*/       /*1*/\nfunction comprobarSiPuedeGenerarCompuestos(primeraPalabra, prefijoPrimeraPalabra, segundaPalabra, prefijoSegundaPalabra, mapa) {\n\n    //Mirar si tiene los formatos correctos (2 textos y 2 números)\n    if (posibleTexto(primeraPalabra) && posibleTexto(segundaPalabra) && posibleNumero(prefijoPrimeraPalabra) && posibleNumero(prefijoSegundaPalabra)) {\n\n        //Se asegura de que la suma de los dos prefijos es menor que al número total de prefijos\n        if (prefijoPrimeraPalabra + prefijoSegundaPalabra <= numeroDePrefijos) {\n\n            //Eliminar los Nitrogenoides el carbonoide\n\n\n            //Asegurarse de que el compuesto esta simplificado al máximo\n            if (prefijoPrimeraPalabra > 1 && prefijoSegundaPalabra > 1) {\n\n                //Almacena el valor maximo del número de oxidación\n\n                var max, min;\n\n                //Almacena el resultado de la división de max/min\n\n                let division;\n\n                //Si el mayor es primero\n                if (prefijoPrimeraPalabra > prefijoSegundaPalabra) {\n\n                    max = prefijoPrimeraPalabra;\n\n                    min = prefijoSegundaPalabra;\n\n                }\n                //sino\n                else {\n                    max = prefijoSegundaPalabra;\n\n                    min = prefijoPrimeraPalabra;\n\n                }\n\n                //Divide el máximo entre el mínimo\n                division = max / min;\n\n                console.log(\"funciona correctamente\");\n\n                console.info(division);\n\n                //Si el valor de la division es igual a la prate entera de la división\n                //Es decir comprueba si es entero o decimal\n\n                if (division === Math.floor(division)/*Math.floor() saca la parte entera de la coma*/) {\n\n                    return false;\n\n                }\n\n\n            }\n\n            //Se asegura de que los compuestos estan\n            if (comprobarSiEstanLosCompuestos(primeraPalabra, prefijoPrimeraPalabra, mapa) && comprobarSiEstanLosCompuestos(segundaPalabra, prefijoSegundaPalabra, mapa)) {\n\n                //Almaceno lo que se va ha devolver\n                var devol;\n\n                //Array de objetos que almacena los objetos utilizados para este compuesto\n                var arrayCompuesto = crearArrayCompuesto(); //Crea un array corresponde al compuesto\n\n                if (arrayCompuesto[0].nombre.toLocaleLowerCase() === hidrogeno) {\n\n                    console.log(\"CArbonoides,Nitrogenoides\");\n\n                    if (arrayCompuesto[1].grupo === 15) {\n\n                        if (prefijoPrimeraPalabra != 3) {\n                            return false;\n                        }\n\n                    } else if (arrayCompuesto[1].nombre.toLocaleLowerCase() === carbono) {\n\n                        if (prefijoPrimeraPalabra != 4) {\n                            return false;\n                        }\n\n                    }\n\n                }\n\n                //Devolver el valor de neutro\n                const devolver = neutro();\n\n                if (devolver === true) {\n                    //Calcula puntaución, la cual requiere un mapa de el compuesto, para eso utilizo la función de crearMapaCompuesto la cual pide un array de elemen\n                    devol = calcularPuntuacion(crearMapaCompuestoPuntuacion(arrayCompuesto, [prefijoPrimeraPalabra, prefijoSegundaPalabra]));\n\n                }\n\n                else {\n                    devol = false;\n                }\n\n                return devol;\n\n                //funcion que dice si da neutro (0) o estable\n\n                function neutro() {\n\n                    var valencias1, valencias2;\n\n                    //Crea el array de valencias sumadas de cada elemento\n                    valencias1 = operar(arrayCompuesto[0].v, prefijoPrimeraPalabra);\n\n                    valencias2 = operar(arrayCompuesto[1].v, prefijoSegundaPalabra);\n\n                    //Comprueva si la suma de los arrays de valencias es neutro\n                    if (sumar(valencias1, valencias2)) {\n\n                        return true;\n\n                    } else {\n\n                        return -1;\n                    }\n\n                    //Suma todas las casillas de todos los arrays\n\n                    function sumar(array1, array2) {\n\n                        //Coge la casilla indicada del array\n                        for (var i = 0; i < array1.length; i++) {\n\n                            //Coge la casilla indicada del 2º array\n                            for (var j = 0; j < array2.length; j++) {\n\n                                //Si la suma de los arrays es o deveulve true por que es neutro\n                                if ((array1[i] + array2[j]) === 0) {\n\n                                    return true;\n                                }\n                            }\n                        }\n\n                        //Si no devuelve true devulve false\n                        return false;\n                    }\n\n                    //Multiplica las valencias por el numero de repeticiones del elmetneo\n                    function operar(valencias, repeticiones) {\n\n                        var arrayVuelta = [];   //El array que devolveras\n\n                        // Se ejecuta una ve por cada casilla del array\n                        for (var i = 0; i < valencias.length; i++) {\n\n                            //Multiplica la casilla de la valencia por las repeticiones y la añade al array\n                            arrayVuelta.push(valencias[i] * repeticiones);\n\n                        }\n\n                        return arrayVuelta;     //Multiplica el array\n\n                    }\n                }\n\n                //Función que estrae los datos necesarios\n                function crearArrayCompuesto() {\n\n                    var arrayCompuesto = [];    //Crea el a el array\n\n                    //Se ejecuta una vez por cada elemento del array\n                    mapa.forEach(function (valor, key) {\n\n                        anadir(primeraPalabra, key);\n\n                    });\n\n                    //Se ejecuta una vez por cada elemento del array\n\n                    mapa.forEach(function (valor, key) {\n\n                        anadir(segundaPalabra, key);\n\n                    });\n\n                    //Añade el elemento al array\n                    function anadir(palabra, key) {\n                        //Si es igual lo añade\n                        if (key.nombre.toLocaleLowerCase() === palabra) {\n\n                            arrayCompuesto.push(key);   //Añade al array la palabra\n\n                        }\n                    }\n\n                    return arrayCompuesto;  // Devuelve el array\n                }\n\n            }\n\n        }\n\n        //Error\n        else {\n            return -1;\n        }\n\n        //Error    \n    }\n    else {\n\n        return -1;\n\n    }\n\n\n    //Comueva si es un texto\n    function posibleTexto(text) {\n\n        return typeof text === \"string\";\n\n    }\n\n    //Compreuva si es un numero\n\n    function posibleNumero(numero) {\n\n        return typeof numero === \"number\";\n\n    }\n\n    //funcion para comprobar si esta el elemento\n\n    function comprobarSiEstanLosCompuestos(nombre, numero, map) {\n\n        var devolucion = false; //Variable que será devuelta\n\n        map.forEach(function (value, key) {\n\n\n            //Comprueva si el elemento esta dentro del map  y tiene tantas repeticiones como es indicado por el prfijo\n\n            if (key.nombre.toLocaleLowerCase() === nombre && value >= numero) {\n\n                devolucion = true;\n\n            }\n        });\n\n        return devolucion;\n\n    }\n\n}\n\n//funcion àra coomprovar si hay hidrogeno\n\nfunction comprobarSiHayHidrogeno(mapaElementos) {\n\n    var devolver = false;   //Lo que se devolvera\n\n    //Mirar si el hidrogeno se encuentra en el mapa de los elementos\n    mapaElementos.forEach(function (value, key) {\n\n        const sqElemento = key.sq; //Coge de la clave\n\n        //Si el sq es igual a la del hidrógeno\n        if (sqElemento === \"H\") {\n\n            devolver = true;    //Cambia la devolución a true\n\n        }\n    });\n\n    return devolver;    //Devuelve\n\n}\n\nexport default comprobarCompuesto;\nexport { comprobarSiHayHidrogeno };"]},"metadata":{},"sourceType":"module"}