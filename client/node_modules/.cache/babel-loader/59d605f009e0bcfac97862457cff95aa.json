{"ast":null,"code":"import{oxido}from'./palabrasClaves';import{noMetales}from'./main';import extraerPrefijos from'./extraerPrefijo';import nombresEquivalentes from'./EquivalenciasNombres';import comprobarSiHayElementoPorNombre from'./comprobarSiHayPorNombre';import buscarElementoEnMapa from'./buscarEnMapCompuestos';import comprobarOrdenCorrecto from'./ComprobarOrden';import comprobarCompuestoBinario from'./compuestoBinario';// Funcion que se ocupa de encontar las sales bianrias, su objetivo es:\n// ejecutar la función de identificar compuestouna vez por cada tipo de sal \n// binaria que pueda encontrar\nfunction comprobarSalesBinariasVolatiles(textoUsuario,mapaElementos,elementosDisponibles){for(var i=0;i<noMetales.length;i++){if(textoUsuario.includes(noMetales[i].nuevoNombreElemento.toLowerCase())&&buscarElementoEnMapa(mapaElementos,noMetales[i].sq)){//Zona de mirar si tiene el orden correcto de la z\nvar comprobarSiEsCorrecto=function comprobarSiEsCorrecto(texto,a){//Guarda el nommbre del compuesto en forma de matriz de palabras\nvar textoPartido=[];//almacena el elemento\nvar textoSinPrefijo;//almacenara la salida de comproca Si hay elemento por nombre\nvar salidaComprobarSiHayElementoPorNombre;//Quitar los espacios de palabra ha pricipio de  texto\ntexto=texto.trim();//Recorta por espacios y lo combierte en un array de palabras\ntextoPartido=texto.split(\" \");//Extrae el prefijo de la última palabra de texto partido y lo almacena\ntextoSinPrefijo=extraerPrefijos(textoPartido[textoPartido.length-1]);//asigan ha salidaComprobarSiHayElementoPorNombre la salida de \nsalidaComprobarSiHayElementoPorNombre=comprobarSiHayElementoPorNombre(textoSinPrefijo,elementosDisponibles);if(salidaComprobarSiHayElementoPorNombre===false||salidaComprobarSiHayElementoPorNombre.nombre.toLowerCase()===nombresEquivalentes(oxido)){return false;}else{//Almacena el primer elemento\nvar primerElmento=comprobarSiHayElementoPorNombre(nombresEquivalentes(noMetales[a].nuevoNombreElemento.toLowerCase()),elementosDisponibles);}return comprobarOrdenCorrecto(primerElmento,salidaComprobarSiHayElementoPorNombre);};//Cmprueba si es correcto el orden del texto del usuario\nif(comprobarSiEsCorrecto(textoUsuario,i)===false){return false;}//Deveulve el resultado\nelse{return comprobarCompuestoBinario(noMetales[i].nuevoNombreElemento.toLowerCase(),textoUsuario,mapaElementos,elementosDisponibles);}}}//Devuelve falso si no encuentra nada\nreturn false;}export default comprobarSalesBinariasVolatiles;","map":{"version":3,"sources":["/home/javi/Programacion/Web/Formulacion/client/src/EncontrarSalesBinariasVolatiles.js"],"names":["oxido","noMetales","extraerPrefijos","nombresEquivalentes","comprobarSiHayElementoPorNombre","buscarElementoEnMapa","comprobarOrdenCorrecto","comprobarCompuestoBinario","comprobarSalesBinariasVolatiles","textoUsuario","mapaElementos","elementosDisponibles","i","length","includes","nuevoNombreElemento","toLowerCase","sq","comprobarSiEsCorrecto","texto","a","textoPartido","textoSinPrefijo","salidaComprobarSiHayElementoPorNombre","trim","split","nombre","primerElmento"],"mappings":"AAAA,OAASA,KAAT,KAAsB,kBAAtB,CAEA,OAASC,SAAT,KAA0B,QAA1B,CACA,MAAOC,CAAAA,eAAP,KAA4B,kBAA5B,CACA,MAAOC,CAAAA,mBAAP,KAAgC,wBAAhC,CAEA,MAAOC,CAAAA,+BAAP,KAA4C,2BAA5C,CACA,MAAOC,CAAAA,oBAAP,KAAiC,yBAAjC,CACA,MAAOC,CAAAA,sBAAP,KAAmC,kBAAnC,CAEA,MAAOC,CAAAA,yBAAP,KAAsC,oBAAtC,CAGA;AACA;AACA;AAEA,QAASC,CAAAA,+BAAT,CAAyCC,YAAzC,CAAuDC,aAAvD,CAAsEC,oBAAtE,CAA4F,CAIxF,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGX,SAAS,CAACY,MAA9B,CAAsCD,CAAC,EAAvC,CAA2C,CAEvC,GAAIH,YAAY,CAACK,QAAb,CAAsBb,SAAS,CAACW,CAAD,CAAT,CAAaG,mBAAb,CAAiCC,WAAjC,EAAtB,GAAyEX,oBAAoB,CAACK,aAAD,CAAgBT,SAAS,CAACW,CAAD,CAAT,CAAaK,EAA7B,CAAjG,CAAmI,CAE/H;AAF+H,GAKtHC,CAAAA,qBALsH,CAK/H,QAASA,CAAAA,qBAAT,CAA+BC,KAA/B,CAAsCC,CAAtC,CAAyC,CAErC;AACA,GAAIC,CAAAA,YAAY,CAAG,EAAnB,CAEA;AACA,GAAIC,CAAAA,eAAJ,CAEA;AACA,GAAIC,CAAAA,qCAAJ,CAEA;AAEAJ,KAAK,CAAGA,KAAK,CAACK,IAAN,EAAR,CAEA;AACAH,YAAY,CAAGF,KAAK,CAACM,KAAN,CAAY,GAAZ,CAAf,CAEA;AACAH,eAAe,CAAGpB,eAAe,CAACmB,YAAY,CAACA,YAAY,CAACR,MAAb,CAAsB,CAAvB,CAAb,CAAjC,CAEA;AACAU,qCAAqC,CAAGnB,+BAA+B,CAACkB,eAAD,CAAkBX,oBAAlB,CAAvE,CAEA,GAAIY,qCAAqC,GAAK,KAA1C,EAAmDA,qCAAqC,CAACG,MAAtC,CAA6CV,WAA7C,KAA+Db,mBAAmB,CAACH,KAAD,CAAzI,CAAkJ,CAE9I,MAAO,MAAP,CAEH,CAJD,IAIO,CAEH;AAEA,GAAI2B,CAAAA,aAAa,CAAGvB,+BAA+B,CAACD,mBAAmB,CAACF,SAAS,CAACmB,CAAD,CAAT,CAAaL,mBAAb,CAAiCC,WAAjC,EAAD,CAApB,CAAsEL,oBAAtE,CAAnD,CAEH,CAGD,MAAOL,CAAAA,sBAAsB,CAACqB,aAAD,CAAgBJ,qCAAhB,CAA7B,CAEH,CA5C8H,CA8C/H;AACA,GAAIL,qBAAqB,CAACT,YAAD,CAAeG,CAAf,CAArB,GAA2C,KAA/C,CAAsD,CAClD,MAAO,MAAP,CACH,CACD;AAHA,IAIK,CACD,MAAOL,CAAAA,yBAAyB,CAACN,SAAS,CAACW,CAAD,CAAT,CAAaG,mBAAb,CAAiCC,WAAjC,EAAD,CAAiDP,YAAjD,CAA+DC,aAA/D,CAA8EC,oBAA9E,CAAhC,CAEH,CACJ,CAEJ,CAED;AAEA,MAAO,MAAP,CAEH,CAED,cAAeH,CAAAA,+BAAf","sourcesContent":["import { oxido } from './palabrasClaves';\n\nimport { noMetales } from './main';\nimport extraerPrefijos from './extraerPrefijo';\nimport nombresEquivalentes from './EquivalenciasNombres';\n\nimport comprobarSiHayElementoPorNombre from './comprobarSiHayPorNombre';\nimport buscarElementoEnMapa from './buscarEnMapCompuestos';\nimport comprobarOrdenCorrecto from './ComprobarOrden';\n\nimport comprobarCompuestoBinario from './compuestoBinario';\n\n\n// Funcion que se ocupa de encontar las sales bianrias, su objetivo es:\n// ejecutar la función de identificar compuestouna vez por cada tipo de sal \n// binaria que pueda encontrar\n\nfunction comprobarSalesBinariasVolatiles(textoUsuario, mapaElementos, elementosDisponibles) {\n\n\n\n    for (var i = 0; i < noMetales.length; i++) {\n\n        if (textoUsuario.includes(noMetales[i].nuevoNombreElemento.toLowerCase()) && buscarElementoEnMapa(mapaElementos, noMetales[i].sq)) {\n\n            //Zona de mirar si tiene el orden correcto de la z\n\n\n            function comprobarSiEsCorrecto(texto, a) {\n\n                //Guarda el nommbre del compuesto en forma de matriz de palabras\n                var textoPartido = [];\n\n                //almacena el elemento\n                var textoSinPrefijo;\n\n                //almacenara la salida de comproca Si hay elemento por nombre\n                var salidaComprobarSiHayElementoPorNombre;\n\n                //Quitar los espacios de palabra ha pricipio de  texto\n\n                texto = texto.trim();\n\n                //Recorta por espacios y lo combierte en un array de palabras\n                textoPartido = texto.split(\" \");\n\n                //Extrae el prefijo de la última palabra de texto partido y lo almacena\n                textoSinPrefijo = extraerPrefijos(textoPartido[textoPartido.length - 1]);\n\n                //asigan ha salidaComprobarSiHayElementoPorNombre la salida de \n                salidaComprobarSiHayElementoPorNombre = comprobarSiHayElementoPorNombre(textoSinPrefijo, elementosDisponibles);\n\n                if (salidaComprobarSiHayElementoPorNombre === false || salidaComprobarSiHayElementoPorNombre.nombre.toLowerCase() === nombresEquivalentes(oxido)) {\n\n                    return false;\n\n                } else {\n\n                    //Almacena el primer elemento\n\n                    var primerElmento = comprobarSiHayElementoPorNombre(nombresEquivalentes(noMetales[a].nuevoNombreElemento.toLowerCase()), elementosDisponibles);\n\n                }\n\n\n                return comprobarOrdenCorrecto(primerElmento, salidaComprobarSiHayElementoPorNombre);\n\n            }\n\n            //Cmprueba si es correcto el orden del texto del usuario\n            if (comprobarSiEsCorrecto(textoUsuario, i) === false) {\n                return false;\n            }\n            //Deveulve el resultado\n            else {\n                return comprobarCompuestoBinario(noMetales[i].nuevoNombreElemento.toLowerCase(), textoUsuario, mapaElementos, elementosDisponibles);\n\n            }\n        }\n\n    }\n\n    //Devuelve falso si no encuentra nada\n\n    return false;\n\n}\n\nexport default comprobarSalesBinariasVolatiles;"]},"metadata":{},"sourceType":"module"}