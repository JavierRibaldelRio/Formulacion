{"ast":null,"code":"// Funcion que se ocupa de encontar las sales bianrias, su objetivo es:\n// ejecutar la función de identificar compuestouna vez por cada tipo de sal \n// binaria que pueda encontrar\nfunction comprobarSalesBinariasVolatiles(textoUsuario, mapaElementos, elementosDisponibles) {\n  for (var i = 0; i < noMetales.length; i++) {\n    if (textoUsuario.includes(noMetales[i].nuevoNombreElemento.toLowerCase()) && buscarElementoEnMapa(mapaElementos, noMetales[i].sq)) {\n      //Zona de mirar si tiene el orden correcto de la z\n      function comprobarSiEsCorrecto(texto) {\n        //Guarda el nommbre del compuesto en forma de matriz de palabras\n        var textoPartido = []; //almacena el elemento\n\n        var textoSinPrefijo; //almacenara la salida de comproca Si hay elemento por nombre\n\n        var salidaComprobarSiHayElementoPorNombre; //Quitar los espacios de palabra ha pricipio de  texto\n\n        texto = texto.trim(); //Recorta por espacios y lo combierte en un array de palabras\n\n        textoPartido = texto.split(\" \"); //Extrae el prefijo de la última palabra de texto partido y lo almacena\n\n        textoSinPrefijo = extraerPrefijos(textoPartido[textoPartido.length - 1]); //asigan ha salidaComprobarSiHayElementoPorNombre la salida de \n\n        salidaComprobarSiHayElementoPorNombre = comprobarSiHayElementoPorNombre(textoSinPrefijo, elementosDisponibles);\n\n        if (salidaComprobarSiHayElementoPorNombre === false || salidaComprobarSiHayElementoPorNombre.nombre.toLowerCase() === nombresEquivalentes(oxido)) {\n          return false;\n        } else {\n          //Almacena el primer elemento\n          var primerElmento = comprobarSiHayElementoPorNombre(nombresEquivalentes(noMetales[i].nuevoNombreElemento.toLowerCase()), elementosDisponibles);\n        }\n\n        return comprobarOrdenCorrecto(primerElmento, salidaComprobarSiHayElementoPorNombre);\n      } //Cmprueba si es correcto el orden del texto del usuario\n\n\n      if (comprobarSiEsCorrecto(textoUsuario) === false) {\n        return false;\n      } //Deveulve el resultado\n      else {\n          return comprobarCompuestoBinario(noMetales[i].nuevoNombreElemento.toLowerCase(), textoUsuario, mapaElementos, elementosDisponibles);\n        }\n    }\n  } //Devuelve falso si no encuentra nada\n\n\n  return false;\n}\n\nexport default comprobarSalesBinariasVolatiles;","map":{"version":3,"sources":["/home/javi/Programacion/Web/Formulacion/src/EncontrarSalesBinariasVolatiles.js"],"names":["comprobarSalesBinariasVolatiles","textoUsuario","mapaElementos","elementosDisponibles","i","noMetales","length","includes","nuevoNombreElemento","toLowerCase","buscarElementoEnMapa","sq","comprobarSiEsCorrecto","texto","textoPartido","textoSinPrefijo","salidaComprobarSiHayElementoPorNombre","trim","split","extraerPrefijos","comprobarSiHayElementoPorNombre","nombre","nombresEquivalentes","oxido","primerElmento","comprobarOrdenCorrecto","comprobarCompuestoBinario"],"mappings":"AAAA;AACA;AACA;AAEA,SAASA,+BAAT,CAAyCC,YAAzC,EAAuDC,aAAvD,EAAsEC,oBAAtE,EAA4F;AAIxF,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAEvC,QAAIH,YAAY,CAACM,QAAb,CAAsBF,SAAS,CAACD,CAAD,CAAT,CAAaI,mBAAb,CAAiCC,WAAjC,EAAtB,KAAyEC,oBAAoB,CAACR,aAAD,EAAgBG,SAAS,CAACD,CAAD,CAAT,CAAaO,EAA7B,CAAjG,EAAmI;AAE/H;AAGA,eAASC,qBAAT,CAA+BC,KAA/B,EAAsC;AAElC;AACA,YAAIC,YAAY,GAAG,EAAnB,CAHkC,CAKlC;;AACA,YAAIC,eAAJ,CANkC,CAQlC;;AACA,YAAIC,qCAAJ,CATkC,CAWlC;;AAEAH,QAAAA,KAAK,GAAGA,KAAK,CAACI,IAAN,EAAR,CAbkC,CAelC;;AACAH,QAAAA,YAAY,GAAGD,KAAK,CAACK,KAAN,CAAY,GAAZ,CAAf,CAhBkC,CAkBlC;;AACAH,QAAAA,eAAe,GAAGI,eAAe,CAACL,YAAY,CAACA,YAAY,CAACR,MAAb,GAAsB,CAAvB,CAAb,CAAjC,CAnBkC,CAqBlC;;AACAU,QAAAA,qCAAqC,GAAGI,+BAA+B,CAACL,eAAD,EAAkBZ,oBAAlB,CAAvE;;AAEA,YAAIa,qCAAqC,KAAK,KAA1C,IAAmDA,qCAAqC,CAACK,MAAtC,CAA6CZ,WAA7C,OAA+Da,mBAAmB,CAACC,KAAD,CAAzI,EAAkJ;AAE9I,iBAAO,KAAP;AAEH,SAJD,MAIO;AAEH;AAEA,cAAIC,aAAa,GAAGJ,+BAA+B,CAACE,mBAAmB,CAACjB,SAAS,CAACD,CAAD,CAAT,CAAaI,mBAAb,CAAiCC,WAAjC,EAAD,CAApB,EAAsEN,oBAAtE,CAAnD;AAEH;;AAGD,eAAOsB,sBAAsB,CAACD,aAAD,EAAgBR,qCAAhB,CAA7B;AAEH,OA5C8H,CA8C/H;;;AACA,UAAIJ,qBAAqB,CAACX,YAAD,CAArB,KAAwC,KAA5C,EAAmD;AAC/C,eAAO,KAAP;AACH,OAFD,CAGA;AAHA,WAIK;AACD,iBAAOyB,yBAAyB,CAACrB,SAAS,CAACD,CAAD,CAAT,CAAaI,mBAAb,CAAiCC,WAAjC,EAAD,EAAiDR,YAAjD,EAA+DC,aAA/D,EAA8EC,oBAA9E,CAAhC;AAEH;AACJ;AAEJ,GA/DuF,CAiExF;;;AAEA,SAAO,KAAP;AAEH;;AAED,eAAeH,+BAAf","sourcesContent":["// Funcion que se ocupa de encontar las sales bianrias, su objetivo es:\n// ejecutar la función de identificar compuestouna vez por cada tipo de sal \n// binaria que pueda encontrar\n\nfunction comprobarSalesBinariasVolatiles(textoUsuario, mapaElementos, elementosDisponibles) {\n\n\n\n    for (var i = 0; i < noMetales.length; i++) {\n\n        if (textoUsuario.includes(noMetales[i].nuevoNombreElemento.toLowerCase()) && buscarElementoEnMapa(mapaElementos, noMetales[i].sq)) {\n\n            //Zona de mirar si tiene el orden correcto de la z\n\n\n            function comprobarSiEsCorrecto(texto) {\n\n                //Guarda el nommbre del compuesto en forma de matriz de palabras\n                var textoPartido = [];\n\n                //almacena el elemento\n                var textoSinPrefijo;\n\n                //almacenara la salida de comproca Si hay elemento por nombre\n                var salidaComprobarSiHayElementoPorNombre;\n\n                //Quitar los espacios de palabra ha pricipio de  texto\n\n                texto = texto.trim();\n\n                //Recorta por espacios y lo combierte en un array de palabras\n                textoPartido = texto.split(\" \");\n\n                //Extrae el prefijo de la última palabra de texto partido y lo almacena\n                textoSinPrefijo = extraerPrefijos(textoPartido[textoPartido.length - 1]);\n\n                //asigan ha salidaComprobarSiHayElementoPorNombre la salida de \n                salidaComprobarSiHayElementoPorNombre = comprobarSiHayElementoPorNombre(textoSinPrefijo, elementosDisponibles);\n\n                if (salidaComprobarSiHayElementoPorNombre === false || salidaComprobarSiHayElementoPorNombre.nombre.toLowerCase() === nombresEquivalentes(oxido)) {\n\n                    return false;\n\n                } else {\n\n                    //Almacena el primer elemento\n\n                    var primerElmento = comprobarSiHayElementoPorNombre(nombresEquivalentes(noMetales[i].nuevoNombreElemento.toLowerCase()), elementosDisponibles);\n\n                }\n\n\n                return comprobarOrdenCorrecto(primerElmento, salidaComprobarSiHayElementoPorNombre);\n\n            }\n\n            //Cmprueba si es correcto el orden del texto del usuario\n            if (comprobarSiEsCorrecto(textoUsuario) === false) {\n                return false;\n            }\n            //Deveulve el resultado\n            else {\n                return comprobarCompuestoBinario(noMetales[i].nuevoNombreElemento.toLowerCase(), textoUsuario, mapaElementos, elementosDisponibles);\n\n            }\n        }\n\n    }\n\n    //Devuelve falso si no encuentra nada\n\n    return false;\n\n}\n\nexport default comprobarSalesBinariasVolatiles;"]},"metadata":{},"sourceType":"module"}