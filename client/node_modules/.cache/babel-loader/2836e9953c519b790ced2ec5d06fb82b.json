{"ast":null,"code":"//Importaciones\nimport identificarSustanciasSimples from'./SustanciasSimples';import descartarCartasUsadas from'./eliminarCompuestos';import crearMapaCompuesto from'./crearMapaCompuesto';import calcularPuntuacion from'./calcularPuntos';import identificarCompuestosExcepcionales from'./excepciones';import comprobarCompuestoBinario from'./compuestoBinario';import'./palabrasClaves';import{hidruro,prefijos,oxido}from'./palabrasClaves';import buscarElementoEnMapa from'./buscarEnMapCompuestos';import{sufijo16Y17,hidrogeno,carbono}from'./palabrasClaves';import averiguarHalogenosYAnfigenos from'./averiguarHalogenosAnfigenos';import{numeroDePrefijos}from'./palabrasClaves';import{crearMapaCompuestoPuntuacion}from'./calcularPuntos';import comprobarSalesBinariasVolatiles from'./EncontrarSalesBinariasVolatiles';//Funcion que comprueva si es posible crear este compuesto\nfunction comprobarCompuesto(elementos,compuesto){//Cromprovar si compuesto no es un texto\nif(typeof compuesto!=\"string\"){//Error\nconsole.log(typeof compuesto);}//si es un string\nelse{compuesto=compuesto.trim();//Quita si hay los primes y ultimos espacios\ncompuesto=compuesto.toLocaleLowerCase();//Pasa a minusculas\nvar mapElementos=crearMap();//Crear el mapa de les elementos\nvar compuestoPartido=compuesto.split(\" \");//Comprueba las sustancias simples\nif(compuestoPartido.length===1){var salidaSS=identificarSustanciasSimples(compuestoPartido[0],elementos,mapElementos);if(salidaSS!==false){//Crea el mapa del compuesto\nvar mapaCompuesto=new Map();//Añade el elemento al mapa\nmapaCompuesto.set(salidaSS,2);//eliminar las cartas que han sido usadas\ndescartarCartasUsadas(crearMapaCompuesto([salidaSS.nombre.toLocaleLowerCase()],[2]),elementos);//Devulve la puntuación \nreturn calcularPuntuacion(mapaCompuesto);}else{return identificarCompuestosExcepcionales(compuesto,mapElementos,elementos);}}//Comprueba si es un hidruro\nelse if(compuesto.includes(hidruro)&&buscarElementoEnMapa(mapElementos,\"H\")){return comprobarCompuestoBinario(hidruro,compuesto,mapElementos,elementos);}//comprobar si abace en uro\nelse if(compuestoPartido[0].endsWith(sufijo16Y17)&&compuestoPartido[2].endsWith(\"hidrógeno\")&&comprobarSiHayHidrogeno(mapElementos)){console.log(\"AnfigenoHAlogeno\");//Preparar datos para la función de averiguar\n//Coger la ultima palabra de el array, \nvar prefijoTexto=compuestoPartido[2].split(\"hidrógeno\");//Almacena el prefijo del hidrogeno\nvar prefijo;//Si no hay prefijo o es mono\nif(prefijoTexto[0]===\"\"||prefijoTexto===prefijos[1]){prefijo=1;}//es di\nelse if(prefijoTexto[0]===prefijos[2]){prefijo=2;}else{return false;}var salida=averiguarHalogenosYAnfigenos(compuesto,mapElementos,prefijo,elementos);return salida;}else if(compuesto.includes(oxido)&&buscarElementoEnMapa(mapElementos,\"O\")){return comprobarCompuestoBinario(oxido,compuesto,mapElementos,elementos);}//Parte de sales binarias\nelse{//MIra si es correcto y lo almacena\nvar correcto=comprobarSalesBinariasVolatiles(compuesto,mapElementos,elementos);if(typeof correcto===\"boolean\"){return identificarCompuestosExcepcionales(compuesto,mapElementos,elementos);}else{return correcto;}}}//Funciones\n//Devuelve un mapa <objeto|Nº de repeticiones de ese objeto>\nfunction crearMap(){var mapaElementos=new Map();//Map donde se almacenan el numero de repeticiones de cada elmento\n//Se ejecuta una vez por el número de elementos que hay que coger\nfor(var i=0;i<elementos.length;i++){var elementoOriginal=elementos[i];//Almacena el elemento origianl\nvar contador=1;//Cuenta cuantas veces se repite un elemento\n//si es igual al número \nif(i<elementos.length-1){//repetira esto hasta que el elemento cambie\nwhile(i<elementos.length-1&&elementoOriginal.sq===elementos[1+i].sq){i++;contador++;}}mapaElementos.set(elementoOriginal,contador);//Añade al mapa\n}return mapaElementos;//Retorna el mapa\n}//Funcion para comprobar que prefijo es\n}//Devuelve que prefijo a sido a utilizado, por lo tanto el número\nfunction encontrarPrefijo(particula){//Se repirte una vez por el número de prefijos que haya\nfor(var i=1;i<numeroDePrefijos;i++){//Si la particula es la misma que el prefijo\nif(particula.startsWith(prefijos[i])){return i;//Devuelve el número de la particula\n}}return-1;}//Funcion para saber si el usuario tiene los elementos necesarios para poder crear el compuesto\n/*Hidrogeno*/ /*1*/ /*Litio*/ /*1*/function comprobarSiPuedeGenerarCompuestos(primeraPalabra,prefijoPrimeraPalabra,segundaPalabra,prefijoSegundaPalabra,mapa){//Mirar si tiene los formatos correctos (2 textos y 2 números)\nif(posibleTexto(primeraPalabra)&&posibleTexto(segundaPalabra)&&posibleNumero(prefijoPrimeraPalabra)&&posibleNumero(prefijoSegundaPalabra)){//Se asegura de que la suma de los dos prefijos es menor que al número total de prefijos\n//Eliminar los Nitrogenoides el carbonoide\n//Asegurarse de que el compuesto esta simplificado al máximo\nif(prefijoPrimeraPalabra>1&&prefijoSegundaPalabra>1){//Almacena el valor maximo del número de oxidación\nvar max,min;//Almacena el resultado de la división de max/min\nvar division;//Si el mayor es primero\nif(prefijoPrimeraPalabra>prefijoSegundaPalabra){max=prefijoPrimeraPalabra;min=prefijoSegundaPalabra;}//sino\nelse{max=prefijoSegundaPalabra;min=prefijoPrimeraPalabra;}//Divide el máximo entre el mínimo\ndivision=max/min;console.log(\"funciona correctamente\");console.info(division);//Si el valor de la division es igual a la prate entera de la división\n//Es decir comprueba si es entero o decimal\nif(division===Math.floor(division)/*Math.floor() saca la parte entera de la coma*/){return false;}}//Se asegura de que los compuestos estan\nif(comprobarSiEstanLosCompuestos(primeraPalabra,prefijoPrimeraPalabra,mapa)&&comprobarSiEstanLosCompuestos(segundaPalabra,prefijoSegundaPalabra,mapa)){//funcion que dice si da neutro (0) o estable\nvar neutro=function neutro(){var valencias1,valencias2;//Crea el array de valencias sumadas de cada elemento\nvalencias1=operar(arrayCompuesto[0].v,prefijoPrimeraPalabra);valencias2=operar(arrayCompuesto[1].v,prefijoSegundaPalabra);//Comprueva si la suma de los arrays de valencias es neutro\nif(sumar(valencias1,valencias2)){return true;}else{return-1;}//Suma todas las casillas de todos los arrays\nfunction sumar(array1,array2){//Coge la casilla indicada del array\nfor(var i=0;i<array1.length;i++){//Coge la casilla indicada del 2º array\nfor(var j=0;j<array2.length;j++){//Si la suma de los arrays es o deveulve true por que es neutro\nif(array1[i]+array2[j]===0){return true;}}}//Si no devuelve true devulve false\nreturn false;}//Multiplica las valencias por el numero de repeticiones del elmetneo\nfunction operar(valencias,repeticiones){var arrayVuelta=[];//El array que devolveras\n// Se ejecuta una ve por cada casilla del array\nfor(var i=0;i<valencias.length;i++){//Multiplica la casilla de la valencia por las repeticiones y la añade al array\narrayVuelta.push(valencias[i]*repeticiones);}return arrayVuelta;//Multiplica el array\n}};//Función que estrae los datos necesarios\nvar crearArrayCompuesto=function crearArrayCompuesto(){var arrayCompuesto=[];//Crea el a el array\n//Se ejecuta una vez por cada elemento del array\nmapa.forEach(function(valor,key){anadir(primeraPalabra,key);});//Se ejecuta una vez por cada elemento del array\nmapa.forEach(function(valor,key){anadir(segundaPalabra,key);});//Añade el elemento al array\nfunction anadir(palabra,key){//Si es igual lo añade\nif(key.nombre.toLocaleLowerCase()===palabra){arrayCompuesto.push(key);//Añade al array la palabra\n}}return arrayCompuesto;// Devuelve el array\n};//Almaceno lo que se va ha devolver\nvar devol;//Array de objetos que almacena los objetos utilizados para este compuesto\nvar arrayCompuesto=crearArrayCompuesto();//Crea un array corresponde al compuesto\nif(arrayCompuesto[0].nombre.toLocaleLowerCase()===hidrogeno){console.log(\"CArbonoides,Nitrogenoides\");if(arrayCompuesto[1].grupo===15){if(prefijoPrimeraPalabra!==3){return false;}}else if(arrayCompuesto[1].nombre.toLocaleLowerCase()===carbono){if(prefijoPrimeraPalabra!==4){return false;}}}//Devolver el valor de neutro\nvar devolver=neutro();if(devolver===true){//Calcula puntaución, la cual requiere un mapa de el compuesto, para eso utilizo la función de crearMapaCompuesto la cual pide un array de elemen\ndevol=calcularPuntuacion(crearMapaCompuestoPuntuacion(arrayCompuesto,[prefijoPrimeraPalabra,prefijoSegundaPalabra]));}else{devol=false;}return devol;}//Error    \n}else{return-1;}//Comueva si es un texto\nfunction posibleTexto(text){return typeof text===\"string\";}//Compreuva si es un numero\nfunction posibleNumero(numero){return typeof numero===\"number\";}//funcion para comprobar si esta el elemento\nfunction comprobarSiEstanLosCompuestos(nombre,numero,map){var devolucion=false;//Variable que será devuelta\nmap.forEach(function(value,key){//Comprueva si el elemento esta dentro del map  y tiene tantas repeticiones como es indicado por el prfijo\nif(key.nombre.toLocaleLowerCase()===nombre&&value>=numero){devolucion=true;}});return devolucion;}}//funcion àra coomprovar si hay hidrogeno\nfunction comprobarSiHayHidrogeno(mapaElementos){var devolver=false;//Lo que se devolvera\n//Mirar si el hidrogeno se encuentra en el mapa de los elementos\nmapaElementos.forEach(function(value,key){var sqElemento=key.sq;//Coge de la clave\n//Si el sq es igual a la del hidrógeno\nif(sqElemento===\"H\"){devolver=true;//Cambia la devolución a true\n}});return devolver;//Devuelve\n}export default comprobarCompuesto;export{comprobarSiHayHidrogeno};export{encontrarPrefijo,comprobarSiPuedeGenerarCompuestos};","map":{"version":3,"sources":["/home/javi/Programacion/Web/Formulacion/client/src/funcionCompuesto.js"],"names":["identificarSustanciasSimples","descartarCartasUsadas","crearMapaCompuesto","calcularPuntuacion","identificarCompuestosExcepcionales","comprobarCompuestoBinario","hidruro","prefijos","oxido","buscarElementoEnMapa","sufijo16Y17","hidrogeno","carbono","averiguarHalogenosYAnfigenos","numeroDePrefijos","crearMapaCompuestoPuntuacion","comprobarSalesBinariasVolatiles","comprobarCompuesto","elementos","compuesto","console","log","trim","toLocaleLowerCase","mapElementos","crearMap","compuestoPartido","split","length","salidaSS","mapaCompuesto","Map","set","nombre","includes","endsWith","comprobarSiHayHidrogeno","prefijoTexto","prefijo","salida","correcto","mapaElementos","i","elementoOriginal","contador","sq","encontrarPrefijo","particula","startsWith","comprobarSiPuedeGenerarCompuestos","primeraPalabra","prefijoPrimeraPalabra","segundaPalabra","prefijoSegundaPalabra","mapa","posibleTexto","posibleNumero","max","min","division","info","Math","floor","comprobarSiEstanLosCompuestos","neutro","valencias1","valencias2","operar","arrayCompuesto","v","sumar","array1","array2","j","valencias","repeticiones","arrayVuelta","push","crearArrayCompuesto","forEach","valor","key","anadir","palabra","devol","grupo","devolver","text","numero","map","devolucion","value","sqElemento"],"mappings":"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","sourcesContent":["//Importaciones\n\nimport identificarSustanciasSimples from './SustanciasSimples';\nimport descartarCartasUsadas from './eliminarCompuestos';\nimport crearMapaCompuesto from './crearMapaCompuesto';\nimport calcularPuntuacion from './calcularPuntos';\nimport identificarCompuestosExcepcionales from './excepciones';\nimport comprobarCompuestoBinario from './compuestoBinario';\nimport './palabrasClaves'\nimport { hidruro, prefijos, oxido } from './palabrasClaves';\nimport buscarElementoEnMapa from './buscarEnMapCompuestos';\nimport { sufijo16Y17, hidrogeno, carbono } from './palabrasClaves';\nimport averiguarHalogenosYAnfigenos from './averiguarHalogenosAnfigenos';\nimport { numeroDePrefijos } from './palabrasClaves';\nimport { crearMapaCompuestoPuntuacion } from './calcularPuntos';\nimport comprobarSalesBinariasVolatiles from './EncontrarSalesBinariasVolatiles';\n\n\n\n\n//Funcion que comprueva si es posible crear este compuesto\nfunction comprobarCompuesto(elementos, compuesto) {\n\n    //Cromprovar si compuesto no es un texto\n    if (typeof compuesto != \"string\") {\n\n        //Error\n\n        console.log(typeof compuesto);\n\n    }\n    //si es un string\n    else {\n\n        compuesto = compuesto.trim(); //Quita si hay los primes y ultimos espacios\n\n        compuesto = compuesto.toLocaleLowerCase();  //Pasa a minusculas\n\n        const mapElementos = crearMap();    //Crear el mapa de les elementos\n\n        const compuestoPartido = compuesto.split(\" \");\n        //Comprueba las sustancias simples\n\n        if (compuestoPartido.length === 1) {\n\n            var salidaSS = identificarSustanciasSimples(compuestoPartido[0], elementos, mapElementos);\n\n            if (salidaSS !== false) {\n\n                //Crea el mapa del compuesto\n                var mapaCompuesto = new Map();\n\n                //Añade el elemento al mapa\n                mapaCompuesto.set(salidaSS, 2);\n\n                //eliminar las cartas que han sido usadas\n                descartarCartasUsadas(crearMapaCompuesto([salidaSS.nombre.toLocaleLowerCase()], [2]), elementos);\n\n                //Devulve la puntuación \n                return calcularPuntuacion(mapaCompuesto);\n\n\n            } else {\n\n                return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n\n            }\n\n\n\n\n        }\n        //Comprueba si es un hidruro\n        else if (compuesto.includes(hidruro) && buscarElementoEnMapa(mapElementos, \"H\")) {\n\n            return comprobarCompuestoBinario(hidruro, compuesto, mapElementos, elementos);\n\n        }\n\n        //comprobar si abace en uro\n        else if (compuestoPartido[0].endsWith(sufijo16Y17) && compuestoPartido[2].endsWith(\"hidrógeno\") && comprobarSiHayHidrogeno(mapElementos)) {\n\n            console.log(\"AnfigenoHAlogeno\");\n\n            //Preparar datos para la función de averiguar\n\n            //Coger la ultima palabra de el array, \n            const prefijoTexto = compuestoPartido[2].split(\"hidrógeno\");\n\n            //Almacena el prefijo del hidrogeno\n            var prefijo;\n\n\n            //Si no hay prefijo o es mono\n            if (prefijoTexto[0] === \"\" || prefijoTexto === prefijos[1]) {\n\n                prefijo = 1;\n\n            }\n            //es di\n            else if (prefijoTexto[0] === prefijos[2]) {\n\n                prefijo = 2;\n\n            } else {\n                return false;\n            }\n\n            const salida = averiguarHalogenosYAnfigenos(compuesto, mapElementos, prefijo, elementos);\n\n            return salida;\n        }\n\n        else if (compuesto.includes(oxido) && buscarElementoEnMapa(mapElementos, \"O\")) {\n\n            return comprobarCompuestoBinario(oxido, compuesto, mapElementos, elementos);\n\n        }\n\n        //Parte de sales binarias\n        else {\n\n            //MIra si es correcto y lo almacena\n            let correcto = comprobarSalesBinariasVolatiles(compuesto, mapElementos, elementos);\n\n            if (typeof correcto === \"boolean\") {\n\n                return identificarCompuestosExcepcionales(compuesto, mapElementos, elementos);\n\n            } else {\n\n                return correcto;\n\n            }\n\n        }\n    }\n\n    //Funciones\n\n    //Devuelve un mapa <objeto|Nº de repeticiones de ese objeto>\n    function crearMap() {\n\n        var mapaElementos = new Map();  //Map donde se almacenan el numero de repeticiones de cada elmento\n\n        //Se ejecuta una vez por el número de elementos que hay que coger\n        for (var i = 0; i < elementos.length; i++) {\n\n            var elementoOriginal = elementos[i]; //Almacena el elemento origianl\n\n            var contador = 1;   //Cuenta cuantas veces se repite un elemento\n\n            //si es igual al número \n            if (i < elementos.length - 1) {\n\n                //repetira esto hasta que el elemento cambie\n                while (i < elementos.length - 1 && elementoOriginal.sq === elementos[1 + i].sq) {\n\n                    i++;\n\n                    contador++;\n\n                }\n\n            }\n            mapaElementos.set(elementoOriginal, contador);  //Añade al mapa\n\n        }\n\n        return mapaElementos;   //Retorna el mapa\n    }\n\n\n    //Funcion para comprobar que prefijo es\n\n}\n\n//Devuelve que prefijo a sido a utilizado, por lo tanto el número\nfunction encontrarPrefijo(particula) {\n\n    //Se repirte una vez por el número de prefijos que haya\n    for (var i = 1; i < numeroDePrefijos; i++) {\n\n        //Si la particula es la misma que el prefijo\n        if (particula.startsWith(prefijos[i])) {\n\n            return i;   //Devuelve el número de la particula\n\n        }\n\n    }\n\n    return -1;\n\n}\n\n//Funcion para saber si el usuario tiene los elementos necesarios para poder crear el compuesto\n/*Hidrogeno*/   /*1*/                   /*Litio*/       /*1*/\nfunction comprobarSiPuedeGenerarCompuestos(primeraPalabra, prefijoPrimeraPalabra, segundaPalabra, prefijoSegundaPalabra, mapa) {\n\n    //Mirar si tiene los formatos correctos (2 textos y 2 números)\n    if (posibleTexto(primeraPalabra) && posibleTexto(segundaPalabra) && posibleNumero(prefijoPrimeraPalabra) && posibleNumero(prefijoSegundaPalabra)) {\n\n        //Se asegura de que la suma de los dos prefijos es menor que al número total de prefijos\n\n        //Eliminar los Nitrogenoides el carbonoide\n\n\n        //Asegurarse de que el compuesto esta simplificado al máximo\n        if (prefijoPrimeraPalabra > 1 && prefijoSegundaPalabra > 1) {\n\n            //Almacena el valor maximo del número de oxidación\n\n            var max, min;\n\n            //Almacena el resultado de la división de max/min\n\n            let division;\n\n            //Si el mayor es primero\n            if (prefijoPrimeraPalabra > prefijoSegundaPalabra) {\n\n                max = prefijoPrimeraPalabra;\n\n                min = prefijoSegundaPalabra;\n\n            }\n            //sino\n            else {\n                max = prefijoSegundaPalabra;\n\n                min = prefijoPrimeraPalabra;\n\n            }\n\n            //Divide el máximo entre el mínimo\n            division = max / min;\n\n            console.log(\"funciona correctamente\");\n\n            console.info(division);\n\n            //Si el valor de la division es igual a la prate entera de la división\n            //Es decir comprueba si es entero o decimal\n\n            if (division === Math.floor(division)/*Math.floor() saca la parte entera de la coma*/) {\n\n                return false;\n\n            }\n\n\n        }\n\n        //Se asegura de que los compuestos estan\n        if (comprobarSiEstanLosCompuestos(primeraPalabra, prefijoPrimeraPalabra, mapa) && comprobarSiEstanLosCompuestos(segundaPalabra, prefijoSegundaPalabra, mapa)) {\n\n            //Almaceno lo que se va ha devolver\n            var devol;\n\n            //Array de objetos que almacena los objetos utilizados para este compuesto\n            var arrayCompuesto = crearArrayCompuesto(); //Crea un array corresponde al compuesto\n\n            if (arrayCompuesto[0].nombre.toLocaleLowerCase() === hidrogeno) {\n\n                console.log(\"CArbonoides,Nitrogenoides\");\n\n                if (arrayCompuesto[1].grupo === 15) {\n\n                    if (prefijoPrimeraPalabra !== 3) {\n                        return false;\n                    }\n\n                } else if (arrayCompuesto[1].nombre.toLocaleLowerCase() === carbono) {\n\n                    if (prefijoPrimeraPalabra !== 4) {\n                        return false;\n                    }\n\n                }\n\n            }\n\n            //Devolver el valor de neutro\n            const devolver = neutro();\n\n            if (devolver === true) {\n                //Calcula puntaución, la cual requiere un mapa de el compuesto, para eso utilizo la función de crearMapaCompuesto la cual pide un array de elemen\n                devol = calcularPuntuacion(crearMapaCompuestoPuntuacion(arrayCompuesto, [prefijoPrimeraPalabra, prefijoSegundaPalabra]));\n\n            }\n\n            else {\n                devol = false;\n            }\n\n            return devol;\n\n            //funcion que dice si da neutro (0) o estable\n\n            function neutro() {\n\n                var valencias1, valencias2;\n\n                //Crea el array de valencias sumadas de cada elemento\n                valencias1 = operar(arrayCompuesto[0].v, prefijoPrimeraPalabra);\n\n                valencias2 = operar(arrayCompuesto[1].v, prefijoSegundaPalabra);\n\n                //Comprueva si la suma de los arrays de valencias es neutro\n                if (sumar(valencias1, valencias2)) {\n\n                    return true;\n\n                } else {\n\n                    return -1;\n                }\n\n                //Suma todas las casillas de todos los arrays\n\n                function sumar(array1, array2) {\n\n                    //Coge la casilla indicada del array\n                    for (var i = 0; i < array1.length; i++) {\n\n                        //Coge la casilla indicada del 2º array\n                        for (var j = 0; j < array2.length; j++) {\n\n                            //Si la suma de los arrays es o deveulve true por que es neutro\n                            if ((array1[i] + array2[j]) === 0) {\n\n                                return true;\n                            }\n                        }\n                    }\n\n                    //Si no devuelve true devulve false\n                    return false;\n                }\n\n                //Multiplica las valencias por el numero de repeticiones del elmetneo\n                function operar(valencias, repeticiones) {\n\n                    var arrayVuelta = [];   //El array que devolveras\n\n                    // Se ejecuta una ve por cada casilla del array\n                    for (var i = 0; i < valencias.length; i++) {\n\n                        //Multiplica la casilla de la valencia por las repeticiones y la añade al array\n                        arrayVuelta.push(valencias[i] * repeticiones);\n\n                    }\n\n                    return arrayVuelta;     //Multiplica el array\n\n                }\n            }\n\n            //Función que estrae los datos necesarios\n            function crearArrayCompuesto() {\n\n                var arrayCompuesto = [];    //Crea el a el array\n\n                //Se ejecuta una vez por cada elemento del array\n                mapa.forEach(function (valor, key) {\n\n                    anadir(primeraPalabra, key);\n\n                });\n\n                //Se ejecuta una vez por cada elemento del array\n\n                mapa.forEach(function (valor, key) {\n\n                    anadir(segundaPalabra, key);\n\n                });\n\n                //Añade el elemento al array\n                function anadir(palabra, key) {\n                    //Si es igual lo añade\n                    if (key.nombre.toLocaleLowerCase() === palabra) {\n\n                        arrayCompuesto.push(key);   //Añade al array la palabra\n\n                    }\n                }\n\n                return arrayCompuesto;  // Devuelve el array\n            }\n\n        }\n\n\n\n        //Error    \n    }\n    else {\n\n        return -1;\n\n    }\n\n\n    //Comueva si es un texto\n    function posibleTexto(text) {\n\n        return typeof text === \"string\";\n\n    }\n\n    //Compreuva si es un numero\n\n    function posibleNumero(numero) {\n\n        return typeof numero === \"number\";\n\n    }\n\n    //funcion para comprobar si esta el elemento\n\n    function comprobarSiEstanLosCompuestos(nombre, numero, map) {\n\n        var devolucion = false; //Variable que será devuelta\n\n        map.forEach(function (value, key) {\n\n\n            //Comprueva si el elemento esta dentro del map  y tiene tantas repeticiones como es indicado por el prfijo\n\n            if (key.nombre.toLocaleLowerCase() === nombre && value >= numero) {\n\n                devolucion = true;\n\n            }\n        });\n\n        return devolucion;\n\n    }\n\n}\n\n//funcion àra coomprovar si hay hidrogeno\n\nfunction comprobarSiHayHidrogeno(mapaElementos) {\n\n    var devolver = false;   //Lo que se devolvera\n\n    //Mirar si el hidrogeno se encuentra en el mapa de los elementos\n    mapaElementos.forEach(function (value, key) {\n\n        const sqElemento = key.sq; //Coge de la clave\n\n        //Si el sq es igual a la del hidrógeno\n        if (sqElemento === \"H\") {\n\n            devolver = true;    //Cambia la devolución a true\n\n        }\n    });\n\n    return devolver;    //Devuelve\n\n}\n\nexport default comprobarCompuesto;\nexport { comprobarSiHayHidrogeno };\nexport { encontrarPrefijo, comprobarSiPuedeGenerarCompuestos };"]},"metadata":{},"sourceType":"module"}