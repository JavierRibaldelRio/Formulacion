{"ast":null,"code":"import { prefijos, oxido, numeroDePrefijos, hidruro } from './palabrasClaves';\n\nfunction comprobarCompuestoBinario(compuestoBinarioABuscar, compuesto, mapElementos, elementos) {\n  //Comprobar si el compuesto tiene las suficientes letras para valorarse\n  if (compuesto.trim().split(\" \").length != 3) {\n    return false;\n  } // console.log(\"Incluye hidruro\");\n\n\n  var binarioIncorrecto = true; //para comprobar si hay que avisar al usuario de un error\n\n  var primerPrefijo = prefijos[1]; //Como el monoóxido lleva solo f\n\n  if (compuestoBinarioABuscar === oxido) {\n    primerPrefijo = \"mon\";\n  } //Si lo es comprueba cuantas meleculas tiene de hidruro\n\n\n  if (compuesto.startsWith(compuestoBinarioABuscar) || compuesto.startsWith(primerPrefijo + compuestoBinarioABuscar)) {\n    // console.log(\"mono\");\n    const resultado = ejecucionBinario(1); //Lo que se ha de ejecutar en caso de que sea un hidrudo\n    //Si es falso devuelves resultado\n\n    if (false === resultado) {\n      return false;\n    } //Si no es falso y es verdadero devuelves true\n    else if (typeof resultado === \"number\") {\n        return resultado;\n      }\n  } else {\n    //Se ejecuta una vez por cada prefijo\n    for (var i = 2; i < numeroDePrefijos; i++) {\n      //Comprueba con que prefijos coinciden con el prefijo\n      if (compuesto.startsWith(prefijos[i] + compuestoBinarioABuscar)) {\n        const resultado = ejecucionBinario(i); //Lo que se ha de ejecutar en caso de que sea un hidrudo\n        //Si es falso devuelves resultado\n\n        if (false === resultado) {\n          return false;\n        } //Si no es falso y es verdadero devuelves true\n        else if (typeof resultado === \"number\") {\n            return resultado;\n          }\n\n        i = numeroDePrefijos; //Para que no lo comprueve más el for, de esa forma se deja de comprobar si el prefijo es el mismi\n      }\n    }\n  } //Lo que se tiene que ejecutar si es un hidruro\n\n\n  function ejecucionBinario(numero) {\n    binarioIncorrecto = false; // Para marcar que no ahí error\n\n    var sal = averiguarCompuestoBinario(compuesto, mapElementos, numero, compuestoBinarioABuscar, elementos); // console.log(sal)\n\n    if (typeof sal === \"number\") {\n      return sal;\n    } else {\n      return false;\n    }\n  }\n}\n\nfunction averiguarCompuestoBinario(texto, mapa, prefijoBinario1, primerCompuesto, elementos) {\n  var devolver = false; //Almacena lo que se va ha devolver\n\n  texto = texto.trim(); //Para quitar leos espacios a pricipio de palabra\n\n  var textoSeparado = texto.split(\" \"); //Para separar las palabras en meterlas en un array invididual\n  // console.log(textoSeparado);\n\n  var elemento = textoSeparado[2]; //coger el tercer trozo de el array de palabras torceadas\n\n  var nombreSegundoElemento;\n  var numeroPrefijoSegundoElemento; //Se ejecuta por cada casilla del mapa\n\n  mapa.forEach(function (valor, key) {\n    //Almacena el nombre del segundo compuesto\n    const nombre = key.nombre\n    /*Coger la propiedad*/\n    .toLocaleLowerCase(); //Para pasar a minusculas\n    //Si acaba con nombre\n\n    if (elemento.endsWith(nombre)) {\n      //Prefijo del 2º Elemnto\n      var prefijoMultipicador = elemento.split(nombre)[0]; //Sacar el prefijo\n      //Si no hay particula quiere decir que es 1(mono)\n\n      if (prefijoMultipicador === \"\") {\n        numeroPrefijoSegundoElemento = 1; //Ya que si no hay nada es mono\n      } //Para encontrar el prefijo               \n      else {\n          numeroPrefijoSegundoElemento = encontrarPrefijo(prefijoMultipicador);\n        } // console.log(numeroPrefijoSegundoElemento);\n      //Si número de prefijo es -1 [ERROR] o es de un grupo de los anfigenos o Halogenos\n\n\n      if (numeroPrefijoSegundoElemento === -1) {\n        return false;\n      }\n\n      if (key.grupo > 15 && hidruro === primerCompuesto) {\n        return false;\n      } //Devuelve -2\n      //Asigna a la variable del mapa\n\n\n      nombreSegundoElemento = nombre; //Dice si es posible combinar los introducidios, sumar y comprobar valencias\n\n      devolver = comprobarSiPuedeGenerarCompuestos(nombresEquivalentes(primerCompuesto), prefijoBinario1, nombre, numeroPrefijoSegundoElemento, mapa);\n    }\n  }); //Si es un numero\n\n  if (typeof devolver === \"number\") {\n    //Creamos la matriz del compuesto\n    const elementosUsados = [nombresEquivalentes(primerCompuesto), nombreSegundoElemento.toLocaleLowerCase()];\n    const repeticionesElementosUsados = [prefijoBinario1, numeroPrefijoSegundoElemento];\n    const mapaCompuesto = crearMapaCompuesto(elementosUsados, repeticionesElementosUsados);\n    descartarCartasUsadas(mapaCompuesto, elementos);\n  }\n\n  return devolver;\n}\n\nexport default comprobarCompuestoBinario;","map":{"version":3,"sources":["/home/javi/Programacion/Web/Formulacion/src/compuestoBinario.js"],"names":["prefijos","oxido","numeroDePrefijos","hidruro","comprobarCompuestoBinario","compuestoBinarioABuscar","compuesto","mapElementos","elementos","trim","split","length","binarioIncorrecto","primerPrefijo","startsWith","resultado","ejecucionBinario","i","numero","sal","averiguarCompuestoBinario","texto","mapa","prefijoBinario1","primerCompuesto","devolver","textoSeparado","elemento","nombreSegundoElemento","numeroPrefijoSegundoElemento","forEach","valor","key","nombre","toLocaleLowerCase","endsWith","prefijoMultipicador","encontrarPrefijo","grupo","comprobarSiPuedeGenerarCompuestos","nombresEquivalentes","elementosUsados","repeticionesElementosUsados","mapaCompuesto","crearMapaCompuesto","descartarCartasUsadas"],"mappings":"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","sourcesContent":["import { prefijos, oxido, numeroDePrefijos, hidruro } from './palabrasClaves'\n\nfunction comprobarCompuestoBinario(compuestoBinarioABuscar, compuesto, mapElementos, elementos) {\n\n    //Comprobar si el compuesto tiene las suficientes letras para valorarse\n\n    if (compuesto.trim().split(\" \").length != 3) {\n\n        return false;\n\n    }\n\n    // console.log(\"Incluye hidruro\");\n\n    var binarioIncorrecto = true;   //para comprobar si hay que avisar al usuario de un error\n\n    var primerPrefijo = prefijos[1];\n    //Como el monoóxido lleva solo f\n    if (compuestoBinarioABuscar === oxido) {\n        primerPrefijo = \"mon\"\n    }\n\n    //Si lo es comprueba cuantas meleculas tiene de hidruro\n    if (compuesto.startsWith(compuestoBinarioABuscar) || compuesto.startsWith(primerPrefijo + compuestoBinarioABuscar)) {\n\n        // console.log(\"mono\");\n\n        const resultado = ejecucionBinario(1);  //Lo que se ha de ejecutar en caso de que sea un hidrudo\n\n        //Si es falso devuelves resultado\n        if (false === resultado) {\n\n            return false;\n\n        }\n\n        //Si no es falso y es verdadero devuelves true\n        else if (typeof resultado === \"number\") {\n\n            return resultado;\n\n        }\n\n    } else {\n\n        //Se ejecuta una vez por cada prefijo\n        for (var i = 2; i < numeroDePrefijos; i++) {\n\n            //Comprueba con que prefijos coinciden con el prefijo\n            if (compuesto.startsWith(prefijos[i] + compuestoBinarioABuscar)) {\n\n                const resultado = ejecucionBinario(i);  //Lo que se ha de ejecutar en caso de que sea un hidrudo\n\n                //Si es falso devuelves resultado\n                if (false === resultado) {\n\n                    return false;\n\n                }\n\n                //Si no es falso y es verdadero devuelves true\n                else if (typeof resultado === \"number\") {\n\n                    return resultado;\n\n                }\n\n                i = numeroDePrefijos; //Para que no lo comprueve más el for, de esa forma se deja de comprobar si el prefijo es el mismi\n            }\n\n        }\n\n    }\n\n\n    //Lo que se tiene que ejecutar si es un hidruro\n    function ejecucionBinario(numero) {\n\n        binarioIncorrecto = false;  // Para marcar que no ahí error\n\n        var sal = averiguarCompuestoBinario(compuesto, mapElementos, numero, compuestoBinarioABuscar, elementos);\n\n        // console.log(sal)\n\n        if (typeof sal === \"number\") {\n\n\n            return sal;\n\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n}\n\nfunction averiguarCompuestoBinario(texto, mapa, prefijoBinario1, primerCompuesto, elementos) {\n\n    var devolver = false;   //Almacena lo que se va ha devolver\n\n    texto = texto.trim()    //Para quitar leos espacios a pricipio de palabra\n\n    var textoSeparado = texto.split(\" \");   //Para separar las palabras en meterlas en un array invididual\n\n    // console.log(textoSeparado);\n\n    var elemento = textoSeparado[2];    //coger el tercer trozo de el array de palabras torceadas\n\n    var nombreSegundoElemento;\n\n    var numeroPrefijoSegundoElemento;\n\n    //Se ejecuta por cada casilla del mapa\n    mapa.forEach(function (valor, key) {\n\n        //Almacena el nombre del segundo compuesto\n        const nombre = key.nombre/*Coger la propiedad*/.toLocaleLowerCase();    //Para pasar a minusculas\n\n        //Si acaba con nombre\n        if (elemento.endsWith(nombre)) {\n\n            //Prefijo del 2º Elemnto\n\n            var prefijoMultipicador = elemento.split(nombre)[0]; //Sacar el prefijo\n\n            //Si no hay particula quiere decir que es 1(mono)\n            if (prefijoMultipicador === \"\") {\n\n                numeroPrefijoSegundoElemento = 1;      //Ya que si no hay nada es mono\n\n            }\n\n            //Para encontrar el prefijo               \n            else {\n\n                numeroPrefijoSegundoElemento = encontrarPrefijo(prefijoMultipicador);\n\n            }\n\n            // console.log(numeroPrefijoSegundoElemento);\n\n            //Si número de prefijo es -1 [ERROR] o es de un grupo de los anfigenos o Halogenos\n            if (numeroPrefijoSegundoElemento === -1) {\n\n                return false;\n\n            }\n\n            if (key.grupo > 15 && hidruro === primerCompuesto) {\n                return false;\n            }\n            //Devuelve -2\n\n            //Asigna a la variable del mapa\n\n            nombreSegundoElemento = nombre;\n\n\n\n            //Dice si es posible combinar los introducidios, sumar y comprobar valencias\n            devolver = comprobarSiPuedeGenerarCompuestos(nombresEquivalentes(primerCompuesto), prefijoBinario1, nombre, numeroPrefijoSegundoElemento, mapa);\n\n        }\n\n    });\n\n    //Si es un numero\n    if (typeof devolver === \"number\") {\n\n        //Creamos la matriz del compuesto\n\n        const elementosUsados = [nombresEquivalentes(primerCompuesto), nombreSegundoElemento.toLocaleLowerCase()];\n\n        const repeticionesElementosUsados = [prefijoBinario1, numeroPrefijoSegundoElemento];\n\n        const mapaCompuesto = crearMapaCompuesto(elementosUsados, repeticionesElementosUsados);\n\n        descartarCartasUsadas(mapaCompuesto, elementos);\n    }\n\n    return devolver;\n\n}\n\nexport default comprobarCompuestoBinario;\n"]},"metadata":{},"sourceType":"module"}